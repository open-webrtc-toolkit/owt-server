From a998d9a65fb2ede61e69cc035937d20846a1d3a9 Mon Sep 17 00:00:00 2001
From: Chen Li1 <li1.chen@intel.com>
Date: Mon, 10 Dec 2018 10:52:56 +0800
Subject: [PATCH] Remove Klocwork severity critical warnings

---
 erizo/src/erizo/DtlsTransport.cpp                  |  10 +-
 erizo/src/erizo/Transport.h                        |   4 +-
 erizo/src/erizo/WebRtcConnection.cpp               |   2 +-
 erizo/src/erizo/dtls/DtlsClient.cpp                |   2 +-
 erizo/src/erizo/rtp/BandwidthEstimationHandler.cpp | 267 ---------------------
 erizo/src/erizo/rtp/BandwidthEstimationHandler.h   |  93 -------
 erizo/src/erizo/rtp/FecReceiverHandler.cpp         |  76 ------
 erizo/src/erizo/rtp/FecReceiverHandler.h           |  44 ----
 .../erizo/rtp/LayerBitrateCalculationHandler.cpp   |  68 ------
 .../src/erizo/rtp/LayerBitrateCalculationHandler.h |  43 ----
 erizo/src/erizo/rtp/LayerDetectorHandler.cpp       | 216 -----------------
 erizo/src/erizo/rtp/LayerDetectorHandler.h         |  80 ------
 erizo/src/erizo/rtp/PliPacerHandler.cpp            |  87 -------
 erizo/src/erizo/rtp/PliPacerHandler.h              |  55 -----
 erizo/src/erizo/rtp/QualityFilterHandler.cpp       | 210 ----------------
 erizo/src/erizo/rtp/QualityFilterHandler.h         |  70 ------
 erizo/src/erizo/rtp/QualityManager.cpp             |  24 +-
 erizo/src/erizo/rtp/RtcpProcessorHandler.cpp       |   3 +
 erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.cpp | 214 -----------------
 erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.h   |  73 ------
 erizo/src/erizo/rtp/RtpPaddingRemovalHandler.cpp   | 133 ----------
 erizo/src/erizo/rtp/RtpPaddingRemovalHandler.h     |  48 ----
 erizo/src/erizo/rtp/RtpRetransmissionHandler.cpp   |  11 +-
 erizo/src/erizo/rtp/RtpSlideShowHandler.cpp        | 263 --------------------
 erizo/src/erizo/rtp/RtpSlideShowHandler.h          |  66 -----
 erizo/src/erizo/rtp/RtpTrackMuteHandler.cpp        | 131 ----------
 erizo/src/erizo/rtp/RtpTrackMuteHandler.h          |  59 -----
 erizo/src/erizo/rtp/SRPacketHandler.cpp            |  84 -------
 erizo/src/erizo/rtp/SRPacketHandler.h              |  51 ----
 .../rtp/SenderBandwidthEstimantionHandler.cpp      | 184 --------------
 .../erizo/rtp/SenderBandwidthEstimationHandler.h   |  73 ------
 erizo/src/erizo/rtp/StatsHandler.cpp               |   6 +-
 32 files changed, 42 insertions(+), 2708 deletions(-)
 delete mode 100644 erizo/src/erizo/rtp/BandwidthEstimationHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/BandwidthEstimationHandler.h
 delete mode 100644 erizo/src/erizo/rtp/FecReceiverHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/FecReceiverHandler.h
 delete mode 100644 erizo/src/erizo/rtp/LayerBitrateCalculationHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/LayerBitrateCalculationHandler.h
 delete mode 100644 erizo/src/erizo/rtp/LayerDetectorHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/LayerDetectorHandler.h
 delete mode 100644 erizo/src/erizo/rtp/PliPacerHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/PliPacerHandler.h
 delete mode 100644 erizo/src/erizo/rtp/QualityFilterHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/QualityFilterHandler.h
 delete mode 100644 erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.h
 delete mode 100644 erizo/src/erizo/rtp/RtpPaddingRemovalHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/RtpPaddingRemovalHandler.h
 delete mode 100644 erizo/src/erizo/rtp/RtpSlideShowHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/RtpSlideShowHandler.h
 delete mode 100644 erizo/src/erizo/rtp/RtpTrackMuteHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/RtpTrackMuteHandler.h
 delete mode 100644 erizo/src/erizo/rtp/SRPacketHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/SRPacketHandler.h
 delete mode 100644 erizo/src/erizo/rtp/SenderBandwidthEstimantionHandler.cpp
 delete mode 100644 erizo/src/erizo/rtp/SenderBandwidthEstimationHandler.h

diff --git a/erizo/src/erizo/DtlsTransport.cpp b/erizo/src/erizo/DtlsTransport.cpp
index 67d1d86..bbe7d99 100644
--- a/erizo/src/erizo/DtlsTransport.cpp
+++ b/erizo/src/erizo/DtlsTransport.cpp
@@ -207,14 +207,18 @@ void DtlsTransport::onIceData(packetPtr packet) {
       return;
     }
     if (auto listener = getTransportListener().lock()) {
-      listener->onTransportData(unprotect_packet_, this);
+      if (listener) {
+        listener->onTransportData(unprotect_packet_, this);
+      }
     }
   }
 }
 
 void DtlsTransport::onCandidate(const CandidateInfo &candidate, IceConnection *conn) {
   if (auto listener = getTransportListener().lock()) {
-    listener->onCandidate(candidate, this);
+    if (listener) {
+      listener->onCandidate(candidate, this);
+    }
   }
 }
 
@@ -272,7 +276,7 @@ void DtlsTransport::onDtlsPacket(DtlsSocketContext *ctx, const unsigned char* da
   }
 
   ELOG_DEBUG("%s message: Sending DTLS message, transportName: %s, componentId: %d",
-             toLog(), transport_name.c_str(), packet->comp);
+             toLog(), transport_name.c_str(), packet? packet->comp : -1);
 }
 
 void DtlsTransport::writeDtlsPacket(DtlsSocketContext *ctx, packetPtr packet) {
diff --git a/erizo/src/erizo/Transport.h b/erizo/src/erizo/Transport.h
index cb8116a..1b396d4 100644
--- a/erizo/src/erizo/Transport.h
+++ b/erizo/src/erizo/Transport.h
@@ -61,7 +61,9 @@ class Transport : public std::enable_shared_from_this<Transport>, public IceConn
     }
     state_ = state;
     if (auto listener = getTransportListener().lock()) {
-      listener->updateState(state, this);
+      if (listener) {
+        listener->updateState(state, this);
+      }
     }
   }
   void writeOnIce(int comp, void* buf, int len) {
diff --git a/erizo/src/erizo/WebRtcConnection.cpp b/erizo/src/erizo/WebRtcConnection.cpp
index 41462ee..8cd38e3 100644
--- a/erizo/src/erizo/WebRtcConnection.cpp
+++ b/erizo/src/erizo/WebRtcConnection.cpp
@@ -584,7 +584,7 @@ void WebRtcConnection::read(std::shared_ptr<DataPacket> packet) {
   // PROCESS RTCP
   RtpHeader *head = reinterpret_cast<RtpHeader*> (buf);
   RtcpHeader *chead = reinterpret_cast<RtcpHeader*> (buf);
-  uint32_t recvSSRC;
+  uint32_t recvSSRC = 0;
   if (!chead->isRtcp()) {
     recvSSRC = head->getSSRC();
   } else if (chead->packettype == RTCP_Sender_PT) {  // Sender Report
diff --git a/erizo/src/erizo/dtls/DtlsClient.cpp b/erizo/src/erizo/dtls/DtlsClient.cpp
index 82ee7d7..702daaa 100644
--- a/erizo/src/erizo/dtls/DtlsClient.cpp
+++ b/erizo/src/erizo/dtls/DtlsClient.cpp
@@ -379,7 +379,7 @@ int createCert(const std::string& pAor, int expireDays, int keyLen, X509*& outCe
         }
 
         if (receiver != NULL) {
-          receiver->onHandshakeCompleted(this, clientKey, serverKey, srtp_profile->name);
+          receiver->onHandshakeCompleted(this, clientKey, serverKey, srtp_profile ? srtp_profile->name : "");
         }
       } else {
         ELOG_DEBUG("Peer did not authenticate");
diff --git a/erizo/src/erizo/rtp/BandwidthEstimationHandler.cpp b/erizo/src/erizo/rtp/BandwidthEstimationHandler.cpp
deleted file mode 100644
index e474610..0000000
--- a/erizo/src/erizo/rtp/BandwidthEstimationHandler.cpp
+++ /dev/null
@@ -1,267 +0,0 @@
-#include "rtp/BandwidthEstimationHandler.h"
-
-#include <vector>
-
-#include "./WebRtcConnection.h"
-#include "lib/Clock.h"
-#include "lib/ClockUtils.h"
-
-#include "webrtc/modules/remote_bitrate_estimator/remote_bitrate_estimator_abs_send_time.h"
-#include "webrtc/modules/remote_bitrate_estimator/remote_bitrate_estimator_single_stream.h"
-#include "webrtc/base/logging.h"
-
-namespace erizo {
-
-using webrtc::RemoteBitrateEstimatorSingleStream;
-using webrtc::RemoteBitrateEstimatorAbsSendTime;
-
-DEFINE_LOGGER(BandwidthEstimationHandler, "rtp.BandwidthEstimationHandler");
-
-static const uint32_t kTimeOffsetSwitchThreshold = 30;
-static const uint32_t kMinBitRateAllowed = 10;
-const int kRembSendIntervallMs = 200;
-const uint32_t BandwidthEstimationHandler::kRembMinimumBitrate = 20000;
-
-// % threshold for if we should send a new REMB asap.
-const unsigned int kSendThresholdPercent = 97;
-
-std::unique_ptr<RemoteBitrateEstimator> RemoteBitrateEstimatorPicker::pickEstimator(bool using_absolute_send_time,
-                                                                                    webrtc::Clock* const clock,
-                                                                                    RemoteBitrateObserver *observer) {
-  std::unique_ptr<RemoteBitrateEstimator> rbe;
-  if (using_absolute_send_time) {
-    rbe.reset(new webrtc::RemoteBitrateEstimatorAbsSendTime(observer, clock));
-  } else {
-    rbe.reset(new webrtc::RemoteBitrateEstimatorSingleStream(observer, clock));
-  }
-  return rbe;
-}
-
-BandwidthEstimationHandler::BandwidthEstimationHandler(std::shared_ptr<RemoteBitrateEstimatorPicker> picker) :
-  connection_{nullptr}, clock_{webrtc::Clock::GetRealTimeClock()},
-  picker_{picker},
-  using_absolute_send_time_{false}, packets_since_absolute_send_time_{0},
-  min_bitrate_bps_{kMinBitRateAllowed},
-  bitrate_{0}, last_send_bitrate_{0}, max_video_bw_{300}, last_remb_time_{0},
-  running_{false}, active_{true}, initialized_{false} {
-    rtc::LogMessage::SetLogToStderr(false);
-}
-
-void BandwidthEstimationHandler::enable() {
-  active_ = true;
-}
-
-void BandwidthEstimationHandler::disable() {
-  active_ = false;
-}
-
-void BandwidthEstimationHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-
-  if (pipeline) {
-    auto rtcp_processor = pipeline->getService<RtcpProcessor>();
-    if (rtcp_processor) {
-      max_video_bw_ = rtcp_processor->getMaxVideoBW();
-    }
-  }
-
-  if (initialized_) {
-    return;
-  }
-
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-  }
-  if (!connection_) {
-    return;
-  }
-  worker_ = connection_->getWorker();
-  stats_ = pipeline->getService<Stats>();
-  RtpExtensionProcessor& ext_processor = connection_->getRtpExtensionProcessor();
-  if (ext_processor.getVideoExtensionMap().size() == 0) {
-    return;
-  }
-  updateExtensionMaps(ext_processor.getVideoExtensionMap(), ext_processor.getAudioExtensionMap());
-
-  pickEstimator();
-  initialized_ = true;
-}
-
-void BandwidthEstimationHandler::process() {
-  rbe_->Process();
-  std::weak_ptr<BandwidthEstimationHandler> weak_ptr = shared_from_this();
-  worker_->scheduleFromNow([weak_ptr]() {
-    if (auto this_ptr = weak_ptr.lock()) {
-      this_ptr->process();
-    }
-  }, std::chrono::milliseconds(rbe_->TimeUntilNextProcess()));
-}
-
-void BandwidthEstimationHandler::updateExtensionMaps(std::array<RTPExtensions, 10> video_map,
-                                                     std::array<RTPExtensions, 10> audio_map) {
-  updateExtensionMap(true, video_map);
-  updateExtensionMap(false, audio_map);
-}
-
-void BandwidthEstimationHandler::updateExtensionMap(bool is_video, std::array<RTPExtensions, 10> map) {
-  webrtc::RTPExtensionType type = webrtc::kRtpExtensionNone;
-  for (uint8_t id = 0; id < 10; id++) {
-    RTPExtensions extension = map[id];
-    switch (extension) {
-      case RTP_ID:
-      case UNKNOWN:
-        continue;
-        break;
-      case SSRC_AUDIO_LEVEL:
-        type = webrtc::kRtpExtensionAudioLevel;
-        break;
-      case ABS_SEND_TIME:
-        type = webrtc::kRtpExtensionAbsoluteSendTime;
-        break;
-      case TOFFSET:
-        type = webrtc::kRtpExtensionTransmissionTimeOffset;
-        break;
-      case VIDEO_ORIENTATION:
-        type = webrtc::kRtpExtensionVideoRotation;
-        break;
-      case TRANSPORT_CC:
-        type = webrtc::kRtpExtensionTransportSequenceNumber;
-        break;
-      case PLAYBACK_TIME:
-        type = webrtc::kRtpExtensionPlayoutDelay;
-        break;
-    }
-    if (type == webrtc::kRtpExtensionNone) {
-      continue;
-    }
-    if (is_video) {
-      ext_map_video_.RegisterByType(id, type);
-    } else {
-      ext_map_audio_.RegisterByType(id, type);
-    }
-  }
-}
-
-void BandwidthEstimationHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (initialized_ && !running_) {
-    process();
-    running_ = true;
-  }
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*> (packet->data);
-  if (!chead->isRtcp() && packet->type == VIDEO_PACKET) {
-    if (parsePacket(packet)) {
-      int64_t arrival_time_ms = packet->received_time_ms;
-      arrival_time_ms = clock_->TimeInMilliseconds() - (ClockUtils::timePointToMs(clock::now()) - arrival_time_ms);
-      size_t payload_size = packet->length;
-      pickEstimatorFromHeader();
-      rbe_->IncomingPacket(arrival_time_ms, payload_size, header_);
-    } else {
-      ELOG_DEBUG("Packet not parsed %d", packet->type);
-    }
-  }
-  ctx->fireRead(std::move(packet));
-}
-
-bool BandwidthEstimationHandler::parsePacket(std::shared_ptr<DataPacket> packet) {
-  const uint8_t* buffer = reinterpret_cast<uint8_t*>(packet->data);
-  size_t length = packet->length;
-  webrtc::RtpUtility::RtpHeaderParser rtp_parser(buffer, length);
-  memset(&header_, 0, sizeof(header_));
-  RtpHeaderExtensionMap map = getHeaderExtensionMap(packet);
-  return rtp_parser.Parse(&header_, &map);
-}
-
-RtpHeaderExtensionMap BandwidthEstimationHandler::getHeaderExtensionMap(std::shared_ptr<DataPacket> packet) const {
-  RtpHeaderExtensionMap map;
-  switch (packet->type) {
-    case VIDEO_PACKET:
-      return ext_map_video_;
-      break;
-    case AUDIO_PACKET:
-      return ext_map_audio_;
-      break;
-    default:
-      ELOG_INFO("Won't process RTP extensions for unknown type packets");
-      return {};
-      break;
-  }
-}
-
-void BandwidthEstimationHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  ctx->fireWrite(std::move(packet));
-}
-
-void BandwidthEstimationHandler::pickEstimatorFromHeader() {
-  if (header_.extension.hasAbsoluteSendTime) {
-    if (!using_absolute_send_time_) {
-      using_absolute_send_time_ = true;
-      pickEstimator();
-    }
-    packets_since_absolute_send_time_ = 0;
-  } else {
-    if (using_absolute_send_time_) {
-      ++packets_since_absolute_send_time_;
-      if (packets_since_absolute_send_time_ >= kTimeOffsetSwitchThreshold) {
-        using_absolute_send_time_ = false;
-        pickEstimator();
-      }
-    }
-  }
-}
-
-void BandwidthEstimationHandler::pickEstimator() {
-  rbe_ = picker_->pickEstimator(using_absolute_send_time_, clock_, this);
-  rbe_->SetMinBitrate(min_bitrate_bps_);
-}
-
-void BandwidthEstimationHandler::sendREMBPacket() {
-  remb_packet_.setPacketType(RTCP_PS_Feedback_PT);
-  remb_packet_.setBlockCount(RTCP_AFB);
-  memcpy(&remb_packet_.report.rembPacket.uniqueid, "REMB", 4);
-
-  remb_packet_.setSSRC(connection_->getVideoSinkSSRC());
-  //  todo(pedro) figure out which sourceSSRC to use here
-  remb_packet_.setSourceSSRC(connection_->getVideoSourceSSRC());
-  remb_packet_.setLength(5);
-  uint32_t capped_bitrate = max_video_bw_ > 0 ? std::min(max_video_bw_, bitrate_) : bitrate_;
-  ELOG_DEBUG("Bitrates min(%u,%u) = %u", bitrate_, max_video_bw_, capped_bitrate);
-  remb_packet_.setREMBBitRate(capped_bitrate);
-  remb_packet_.setREMBNumSSRC(1);
-  remb_packet_.setREMBFeedSSRC(connection_->getVideoSourceSSRC());
-  int remb_length = (remb_packet_.getLength() + 1) * 4;
-  if (active_) {
-    ELOG_DEBUG("BWE Estimation is %d", last_send_bitrate_);
-    getContext()->fireWrite(std::make_shared<DataPacket>(0,
-      reinterpret_cast<char*>(&remb_packet_), remb_length, OTHER_PACKET));
-  }
-}
-
-void BandwidthEstimationHandler::OnReceiveBitrateChanged(const std::vector<uint32_t>& ssrcs,
-                                     uint32_t bitrate) {
-  if (last_send_bitrate_ > 0) {
-    unsigned int new_remb_bitrate = last_send_bitrate_ - bitrate_ + bitrate;
-    if (new_remb_bitrate < kSendThresholdPercent * last_send_bitrate_ / 100) {
-      // The new bitrate estimate is less than kSendThresholdPercent % of the
-      // last report. Send a REMB asap.
-      last_remb_time_ = ClockUtils::timePointToMs(clock::now()) - kRembSendIntervallMs;
-    }
-  }
-
-  if (bitrate < kRembMinimumBitrate) {
-    bitrate = kRembMinimumBitrate;
-  }
-
-  bitrate_ = bitrate;
-
-  uint64_t now = ClockUtils::timePointToMs(clock::now());
-
-  if (now - last_remb_time_ < kRembSendIntervallMs) {
-    return;
-  }
-  last_remb_time_ = now;
-  last_send_bitrate_ = bitrate_;
-  stats_->getNode()[connection_->getVideoSourceSSRC()].insertStat("erizoBandwidth", CumulativeStat{last_send_bitrate_});
-  sendREMBPacket();
-}
-
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/BandwidthEstimationHandler.h b/erizo/src/erizo/rtp/BandwidthEstimationHandler.h
deleted file mode 100644
index be30444..0000000
--- a/erizo/src/erizo/rtp/BandwidthEstimationHandler.h
+++ /dev/null
@@ -1,93 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_BANDWIDTHESTIMATIONHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_BANDWIDTHESTIMATIONHANDLER_H_
-
-#include <array>
-#include <vector>
-#include <string>
-#include <atomic>
-
-#include "./logger.h"
-#include "./Stats.h"
-#include "pipeline/Handler.h"
-#include "rtp/RtpExtensionProcessor.h"
-
-#include "thread/Worker.h"
-
-#include "webrtc/common_types.h"
-#include "webrtc/modules/remote_bitrate_estimator/include/remote_bitrate_estimator.h"
-#include "webrtc/modules/rtp_rtcp/source/rtp_utility.h"
-#include "webrtc/system_wrappers/include/clock.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-using webrtc::RemoteBitrateEstimator;
-using webrtc::RemoteBitrateObserver;
-using webrtc::RtpHeaderExtensionMap;
-
-class RemoteBitrateEstimatorPicker {
- public:
-  virtual std::unique_ptr<RemoteBitrateEstimator> pickEstimator(bool using_absolute_send_time,
-    webrtc::Clock* const clock, RemoteBitrateObserver *observer);
-};
-
-class BandwidthEstimationHandler: public Handler, public RemoteBitrateObserver,
-                public std::enable_shared_from_this<BandwidthEstimationHandler> {
-  DECLARE_LOGGER();
-
- public:
-  static const uint32_t kRembMinimumBitrate;
-
-  explicit BandwidthEstimationHandler(
-    std::shared_ptr<RemoteBitrateEstimatorPicker> picker = std::make_shared<RemoteBitrateEstimatorPicker>());
-
-  void OnReceiveBitrateChanged(const std::vector<uint32_t>& ssrcs,
-                                       uint32_t bitrate) override;
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "bwe";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
-  void updateExtensionMaps(std::array<RTPExtensions, 10> video_map, std::array<RTPExtensions, 10> audio_map);
-
- private:
-  void process();
-  void sendREMBPacket();
-  bool parsePacket(std::shared_ptr<DataPacket> packet);
-  RtpHeaderExtensionMap getHeaderExtensionMap(std::shared_ptr<DataPacket> packet) const;
-  void pickEstimatorFromHeader();
-  void pickEstimator();
-
-  void updateExtensionMap(bool video, std::array<RTPExtensions, 10> map);
-
-  WebRtcConnection *connection_;
-  std::shared_ptr<Worker> worker_;
-  std::shared_ptr<Stats> stats_;
-  webrtc::Clock* const clock_;
-  std::shared_ptr<RemoteBitrateEstimatorPicker> picker_;
-  std::unique_ptr<RemoteBitrateEstimator> rbe_;
-  bool using_absolute_send_time_;
-  uint32_t packets_since_absolute_send_time_;
-  int min_bitrate_bps_;
-  webrtc::RTPHeader header_;
-  RtcpHeader remb_packet_;
-  RtpHeaderExtensionMap ext_map_audio_, ext_map_video_;
-  uint32_t bitrate_;
-  uint32_t last_send_bitrate_;
-  uint32_t max_video_bw_;
-  uint64_t last_remb_time_;
-  bool running_;
-  bool active_;
-  bool initialized_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_BANDWIDTHESTIMATIONHANDLER_H_
diff --git a/erizo/src/erizo/rtp/FecReceiverHandler.cpp b/erizo/src/erizo/rtp/FecReceiverHandler.cpp
deleted file mode 100644
index 8a57427..0000000
--- a/erizo/src/erizo/rtp/FecReceiverHandler.cpp
+++ /dev/null
@@ -1,76 +0,0 @@
-#include "rtp/FecReceiverHandler.h"
-#include "./MediaDefinitions.h"
-#include "./WebRtcConnection.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(FecReceiverHandler, "rtp.FecReceiverHandler");
-
-FecReceiverHandler::FecReceiverHandler() :
-    enabled_{false} {
-  fec_receiver_.reset(webrtc::UlpfecReceiver::Create(this));
-}
-
-void FecReceiverHandler::setFecReceiver(std::unique_ptr<webrtc::UlpfecReceiver>&& fec_receiver) {  // NOLINT
-  fec_receiver_ = std::move(fec_receiver);
-}
-
-void FecReceiverHandler::enable() {
-  enabled_ = true;
-}
-
-void FecReceiverHandler::disable() {
-  enabled_ = false;
-}
-
-void FecReceiverHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (!pipeline) {
-    return;
-  }
-  std::shared_ptr<WebRtcConnection> connection = pipeline->getService<WebRtcConnection>();
-  if (!connection) {
-    return;
-  }
-  SdpInfo &remote_sdp = connection->getRemoteSdpInfo();
-  bool is_slide_show_mode_active = connection->isSlideShowModeEnabled();
-  if (!remote_sdp.supportPayloadType(RED_90000_PT) || is_slide_show_mode_active) {
-    enable();
-  } else {
-    disable();
-  }
-}
-
-void FecReceiverHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (enabled_ && packet->type == VIDEO_PACKET) {
-    RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-    if (rtp_header->getPayloadType() == RED_90000_PT) {
-      // This is a RED/FEC payload, but our remote endpoint doesn't support that
-      // (most likely because it's firefox :/ )
-      // Let's go ahead and run this through our fec receiver to convert it to raw VP8
-      webrtc::RTPHeader hacky_header;
-      hacky_header.headerLength = rtp_header->getHeaderLength();
-      hacky_header.sequenceNumber = rtp_header->getSeqNumber();
-      // FEC copies memory, manages its own memory, including memory passed in callbacks (in the callback,
-      // be sure to memcpy out of webrtc's buffers
-      if (fec_receiver_->AddReceivedRedPacket(hacky_header,
-                            (const uint8_t*) packet->data, packet->length, ULP_90000_PT) == 0) {
-        fec_receiver_->ProcessReceivedFec();
-      }
-    }
-  }
-
-  ctx->fireWrite(std::move(packet));
-}
-
-bool FecReceiverHandler::OnRecoveredPacket(const uint8_t* rtp_packet, size_t rtp_packet_length) {
-  getContext()->fireWrite(std::make_shared<DataPacket>(0, (char*)rtp_packet, rtp_packet_length, VIDEO_PACKET));  // NOLINT
-  return true;
-}
-
-int32_t FecReceiverHandler::OnReceivedPayloadData(const uint8_t* /*payload_data*/, size_t /*payload_size*/,
-                                                const webrtc::WebRtcRTPHeader* /*rtp_header*/) {
-    // Unused by WebRTC's FEC implementation; just something we have to implement.
-    return 0;
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/FecReceiverHandler.h b/erizo/src/erizo/rtp/FecReceiverHandler.h
deleted file mode 100644
index 4032b60..0000000
--- a/erizo/src/erizo/rtp/FecReceiverHandler.h
+++ /dev/null
@@ -1,44 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_FECRECEIVERHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_FECRECEIVERHANDLER_H_
-
-#include <string>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "webrtc/modules/rtp_rtcp/include/ulpfec_receiver.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class FecReceiverHandler: public OutboundHandler, public webrtc::RtpData {
-  DECLARE_LOGGER();
-
- public:
-  FecReceiverHandler();
-
-  void setFecReceiver(std::unique_ptr<webrtc::UlpfecReceiver>&& fec_receiver);  // NOLINT
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "fec-receiver";
-  }
-
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
-  // webrtc::RtpHeader overrides.
-  int32_t OnReceivedPayloadData(const uint8_t* payloadData, size_t payloadSize,
-                                const webrtc::WebRtcRTPHeader* rtpHeader) override;
-  bool OnRecoveredPacket(const uint8_t* packet, size_t packet_length) override;
-
- private:
-  bool enabled_;
-  std::unique_ptr<webrtc::UlpfecReceiver> fec_receiver_;
-};
-
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_FECRECEIVERHANDLER_H_
diff --git a/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.cpp b/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.cpp
deleted file mode 100644
index ecb2ef9..0000000
--- a/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.cpp
+++ /dev/null
@@ -1,68 +0,0 @@
-#include "rtp/LayerBitrateCalculationHandler.h"
-
-#include <vector>
-
-#include "./WebRtcConnection.h"
-#include "lib/ClockUtils.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(LayerBitrateCalculationHandler, "rtp.LayerBitrateCalculationHandler");
-
-LayerBitrateCalculationHandler::LayerBitrateCalculationHandler() : enabled_{true},
-  initialized_{false} {}
-
-void LayerBitrateCalculationHandler::enable() {
-  enabled_ = true;
-}
-
-void LayerBitrateCalculationHandler::disable() {
-  enabled_ = false;
-}
-
-void LayerBitrateCalculationHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (!enabled_ || !initialized_) {
-    ctx->fireWrite(std::move(packet));
-    return;
-  }
-
-  std::for_each(packet->compatible_spatial_layers.begin(),
-      packet->compatible_spatial_layers.end(), [this, packet](int &layer_num){
-        std::string spatial_layer_name = std::to_string(layer_num);
-        std::for_each(packet->compatible_temporal_layers.begin(),
-          packet->compatible_temporal_layers.end(), [this, packet, spatial_layer_name](int &layer_num){
-            std::string temporal_layer_name = std::to_string(layer_num);
-            if (!stats_->getNode()[kQualityLayersStatsKey][spatial_layer_name].hasChild(temporal_layer_name)) {
-              stats_->getNode()[kQualityLayersStatsKey][spatial_layer_name].insertStat(
-                  temporal_layer_name, MovingIntervalRateStat{kLayerRateStatIntervalSize,
-                  kLayerRateStatIntervals, 8.});
-            } else {
-              stats_->getNode()[kQualityLayersStatsKey][spatial_layer_name][temporal_layer_name]+=packet->length;
-            }
-          });
-      });
-  quality_manager_->notifyQualityUpdate();
-  ctx->fireWrite(std::move(packet));
-}
-
-
-void LayerBitrateCalculationHandler::notifyUpdate() {
-  if (initialized_) {
-    return;
-  }
-
-  auto pipeline = getContext()->getPipelineShared();
-  if (!pipeline) {
-    return;
-  }
-  stats_ = pipeline->getService<Stats>();
-  if (!stats_) {
-    return;
-  }
-  quality_manager_ = pipeline->getService<QualityManager>();
-  if (!quality_manager_) {
-    return;
-  }
-  initialized_ = true;
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.h b/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.h
deleted file mode 100644
index 2535d62..0000000
--- a/erizo/src/erizo/rtp/LayerBitrateCalculationHandler.h
+++ /dev/null
@@ -1,43 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_LAYERBITRATECALCULATIONHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_LAYERBITRATECALCULATIONHANDLER_H_
-
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "./Stats.h"
-#include "rtp/QualityManager.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-constexpr duration kLayerRateStatIntervalSize = std::chrono::milliseconds(100);
-constexpr uint32_t kLayerRateStatIntervals = 30;
-
-class LayerBitrateCalculationHandler: public OutboundHandler {
-  DECLARE_LOGGER();
-
-
- public:
-  LayerBitrateCalculationHandler();
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-     return "layer_bitrate_calculator";
-  }
-
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  const std::string kQualityLayersStatsKey = "qualityLayers";
-  bool enabled_;
-  bool initialized_;
-  std::shared_ptr<Stats> stats_;
-  std::shared_ptr<QualityManager> quality_manager_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_LAYERBITRATECALCULATIONHANDLER_H_
diff --git a/erizo/src/erizo/rtp/LayerDetectorHandler.cpp b/erizo/src/erizo/rtp/LayerDetectorHandler.cpp
deleted file mode 100644
index 20a78dd..0000000
--- a/erizo/src/erizo/rtp/LayerDetectorHandler.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-#include "rtp/LayerDetectorHandler.h"
-
-#include <vector>
-
-#include "./WebRtcConnection.h"
-#include "lib/ClockUtils.h"
-
-namespace erizo {
-
-static constexpr uint32_t kMaxTemporalLayers = 4;
-static constexpr uint32_t kMaxSpatialLayers = 4;
-static constexpr erizo::duration kMinNotifyLayerInfoInterval = std::chrono::seconds(5);
-
-DEFINE_LOGGER(LayerDetectorHandler, "rtp.LayerDetectorHandler");
-
-LayerDetectorHandler::LayerDetectorHandler(std::shared_ptr<erizo::Clock> the_clock)
-    : clock_{the_clock}, connection_{nullptr}, enabled_{true}, initialized_{false},
-    last_event_sent_{clock_->now()} {
-  for (uint32_t temporal_layer = 0; temporal_layer <= kMaxTemporalLayers; temporal_layer++) {
-    video_frame_rate_list_.push_back(MovingIntervalRateStat{std::chrono::milliseconds(500), 10, .5, clock_});
-  }
-  video_frame_width_list_ = std::vector<uint32_t>(kMaxSpatialLayers);
-  video_frame_height_list_ = std::vector<uint32_t>(kMaxSpatialLayers);
-}
-
-void LayerDetectorHandler::enable() {
-  enabled_ = true;
-}
-
-void LayerDetectorHandler::disable() {
-  enabled_ = false;
-}
-
-void LayerDetectorHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (!chead->isRtcp() && enabled_ && packet->type == VIDEO_PACKET) {
-    RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-    RtpMap *codec = connection_->getRemoteSdpInfo().getCodecByExternalPayloadType(rtp_header->getPayloadType());
-    if (codec && codec->encoding_name == "VP8") {
-      packet->codec = "VP8";
-      parseLayerInfoFromVP8(packet);
-    } else if (codec && codec->encoding_name == "VP9") {
-      packet->codec = "VP9";
-      parseLayerInfoFromVP9(packet);
-    } else if (codec && codec->encoding_name == "H264") {
-      packet->codec = "H264";
-      parseLayerInfoFromH264(packet);
-    }
-  }
-  ctx->fireRead(std::move(packet));
-}
-
-void LayerDetectorHandler::notifyLayerInfoChangedEvent() {
-  ELOG_DEBUG("Layer info changed");
-  for (uint32_t spatial_layer = 0; spatial_layer < video_frame_width_list_.size(); spatial_layer++) {
-    ELOG_DEBUG("Spatial Layer (%u): %u %u",
-              spatial_layer, video_frame_width_list_[spatial_layer], video_frame_height_list_[spatial_layer]);
-  }
-  std::vector<uint64_t> video_frame_rate_list;
-  for (uint32_t temporal_layer = 0; temporal_layer < video_frame_rate_list_.size(); temporal_layer++) {
-    video_frame_rate_list.push_back(video_frame_rate_list_[temporal_layer].value());
-    ELOG_DEBUG("Temporal Layer (%u): %lu",
-              temporal_layer, video_frame_rate_list_[temporal_layer].value());
-  }
-
-  if (connection_) {
-    connection_->notifyToEventSink(
-      std::make_shared<LayerInfoChangedEvent>(video_frame_width_list_,
-        video_frame_height_list_, video_frame_rate_list));
-  }
-  last_event_sent_ = clock_->now();
-}
-
-void LayerDetectorHandler::notifyLayerInfoChangedEventMaybe() {
-  if (clock_->now() - last_event_sent_ > kMinNotifyLayerInfoInterval) {
-    notifyLayerInfoChangedEvent();
-  }
-}
-
-int LayerDetectorHandler::getSsrcPosition(uint32_t ssrc) {
-  std::vector<uint32_t>::iterator item = std::find(video_ssrc_list_.begin(), video_ssrc_list_.end(), ssrc);
-  size_t index = std::distance(video_ssrc_list_.begin(), item);
-  if (index != video_ssrc_list_.size()) {
-    return index;
-  }
-  return -1;
-}
-
-void LayerDetectorHandler::parseLayerInfoFromVP8(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  unsigned char* start_buffer = reinterpret_cast<unsigned char*> (packet->data);
-  start_buffer = start_buffer + rtp_header->getHeaderLength();
-  RTPPayloadVP8* payload = vp8_parser_.parseVP8(
-      start_buffer, packet->length - rtp_header->getHeaderLength());
-  if (payload->hasPictureID) {
-    packet->picture_id = payload->pictureID;
-  }
-  packet->compatible_temporal_layers = {};
-  switch (payload->tID) {
-    case 0: addTemporalLayerAndCalculateRate(packet, 0, payload->beginningOfPartition);
-    case 2: addTemporalLayerAndCalculateRate(packet, 1, payload->beginningOfPartition);
-    case 1: addTemporalLayerAndCalculateRate(packet, 2, payload->beginningOfPartition);
-    // case 3 and beyond are not handled because Chrome only
-    // supports 3 temporal scalability today (03/15/17)
-      break;
-    default: addTemporalLayerAndCalculateRate(packet, 0, payload->beginningOfPartition);
-      break;
-  }
-
-  int position = getSsrcPosition(rtp_header->getSSRC());
-  packet->compatible_spatial_layers = {position};
-  if (!payload->frameType) {
-    packet->is_keyframe = true;
-  } else {
-    packet->is_keyframe = false;
-  }
-
-  if (payload->frameWidth != -1 && static_cast<uint>(payload->frameWidth) != video_frame_width_list_[position]) {
-    video_frame_width_list_[position] = payload->frameWidth;
-    video_frame_height_list_[position] = payload->frameHeight;
-    notifyLayerInfoChangedEvent();
-  }
-  notifyLayerInfoChangedEventMaybe();
-  delete payload;
-}
-
-void LayerDetectorHandler::addTemporalLayerAndCalculateRate(const std::shared_ptr<DataPacket> &packet,
-                                                            int temporal_layer, bool new_frame) {
-  if (new_frame) {
-    video_frame_rate_list_[temporal_layer]++;
-  }
-  packet->compatible_temporal_layers.push_back(temporal_layer);
-}
-
-void LayerDetectorHandler::parseLayerInfoFromVP9(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  unsigned char* start_buffer = reinterpret_cast<unsigned char*> (packet->data);
-  start_buffer = start_buffer + rtp_header->getHeaderLength();
-  RTPPayloadVP9* payload = vp9_parser_.parseVP9(
-      start_buffer, packet->length - rtp_header->getHeaderLength());
-
-  int spatial_layer = payload->spatialID;
-
-  packet->compatible_spatial_layers = {};
-  for (int i = 5; i >= spatial_layer; i--) {
-    packet->compatible_spatial_layers.push_back(i);
-  }
-
-  packet->compatible_temporal_layers = {};
-  switch (payload->temporalID) {
-    case 0: addTemporalLayerAndCalculateRate(packet, 0, payload->beginningOfLayerFrame);
-    case 2: addTemporalLayerAndCalculateRate(packet, 1, payload->beginningOfLayerFrame);
-    case 1: addTemporalLayerAndCalculateRate(packet, 2, payload->beginningOfLayerFrame);
-    case 3: addTemporalLayerAndCalculateRate(packet, 3, payload->beginningOfLayerFrame);
-      break;
-    default: addTemporalLayerAndCalculateRate(packet, 0, payload->beginningOfLayerFrame);
-      break;
-  }
-
-  if (!payload->frameType) {
-    packet->is_keyframe = true;
-  } else {
-    packet->is_keyframe = false;
-  }
-  bool resolution_changed = false;
-  if (payload->resolutions.size() > 0) {
-    for (uint position = 0; position < payload->resolutions.size(); position++) {
-      resolution_changed = true;
-      video_frame_width_list_[position] = payload->resolutions[position].width;
-      video_frame_height_list_[position] = payload->resolutions[position].height;
-    }
-  }
-  if (resolution_changed) {
-    notifyLayerInfoChangedEvent();
-  }
-
-  notifyLayerInfoChangedEventMaybe();
-
-  packet->ending_of_layer_frame = payload->endingOfLayerFrame;
-  delete payload;
-}
-
-void LayerDetectorHandler::parseLayerInfoFromH264(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  unsigned char* start_buffer = reinterpret_cast<unsigned char*> (packet->data);
-  start_buffer = start_buffer + rtp_header->getHeaderLength();
-  RTPPayloadH264* payload = h264_parser_.parseH264(
-      start_buffer, packet->length - rtp_header->getHeaderLength());
-
-  if (payload->frameType == kH264IFrame) {
-    packet->is_keyframe = true;
-  } else {
-    packet->is_keyframe = false;
-  }
-
-  delete payload;
-}
-
-void LayerDetectorHandler::notifyUpdate() {
-  if (initialized_) {
-    return;
-  }
-
-  auto pipeline = getContext()->getPipelineShared();
-  if (!pipeline) {
-    return;
-  }
-
-  connection_ = pipeline->getService<WebRtcConnection>().get();
-  if (!connection_) {
-    return;
-  }
-
-  video_ssrc_list_ = connection_->getVideoSourceSSRCList();
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/LayerDetectorHandler.h b/erizo/src/erizo/rtp/LayerDetectorHandler.h
deleted file mode 100644
index 256cf34..0000000
--- a/erizo/src/erizo/rtp/LayerDetectorHandler.h
+++ /dev/null
@@ -1,80 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_LAYERDETECTORHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_LAYERDETECTORHANDLER_H_
-
-#include <memory>
-#include <string>
-#include <random>
-#include <map>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "rtp/RtpVP8Parser.h"
-#include "rtp/RtpVP9Parser.h"
-#include "rtp/RtpH264Parser.h"
-#include "./Stats.h"
-
-#define MAX_DELAY 450000
-
-namespace erizo {
-
-class LayerInfoChangedEvent : public MediaEvent {
- public:
-  LayerInfoChangedEvent(std::vector<uint32_t> video_frame_width_list_, std::vector<uint32_t> video_frame_height_list_,
-                        std::vector<uint64_t> video_frame_rate_list_)
-    : video_frame_width_list{video_frame_width_list_},
-      video_frame_height_list{video_frame_height_list_},
-      video_frame_rate_list{video_frame_rate_list_} {}
-
-  std::string getType() const override {
-    return "LayerInfoChangedEvent";
-  }
-  std::vector<uint32_t> video_frame_width_list;
-  std::vector<uint32_t> video_frame_height_list;
-  std::vector<uint64_t> video_frame_rate_list;
-};
-
-class WebRtcConnection;
-
-class LayerDetectorHandler: public InboundHandler, public std::enable_shared_from_this<LayerDetectorHandler> {
-  DECLARE_LOGGER();
-
-
- public:
-  explicit LayerDetectorHandler(std::shared_ptr<erizo::Clock> the_clock = std::make_shared<erizo::SteadyClock>());
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-     return "layer_detector";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  void parseLayerInfoFromVP8(std::shared_ptr<DataPacket> packet);
-  void parseLayerInfoFromVP9(std::shared_ptr<DataPacket> packet);
-  void parseLayerInfoFromH264(std::shared_ptr<DataPacket> packet);
-  int getSsrcPosition(uint32_t ssrc);
-  void addTemporalLayerAndCalculateRate(const std::shared_ptr<DataPacket> &packet, int temporal_layer, bool new_frame);
-  void notifyLayerInfoChangedEvent();
-  void notifyLayerInfoChangedEventMaybe();
-
- private:
-  std::shared_ptr<erizo::Clock> clock_;
-  WebRtcConnection *connection_;
-  bool enabled_;
-  bool initialized_;
-  RtpVP8Parser vp8_parser_;
-  RtpVP9Parser vp9_parser_;
-  RtpH264Parser h264_parser_;
-  std::vector<uint32_t> video_ssrc_list_;
-  std::vector<uint32_t> video_frame_height_list_;
-  std::vector<uint32_t> video_frame_width_list_;
-  std::vector<MovingIntervalRateStat> video_frame_rate_list_;
-  std::chrono::steady_clock::time_point last_event_sent_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_LAYERDETECTORHANDLER_H_
diff --git a/erizo/src/erizo/rtp/PliPacerHandler.cpp b/erizo/src/erizo/rtp/PliPacerHandler.cpp
deleted file mode 100644
index faf1cf6..0000000
--- a/erizo/src/erizo/rtp/PliPacerHandler.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-#include "rtp/PliPacerHandler.h"
-
-#include "rtp/RtpUtils.h"
-#include "./MediaDefinitions.h"
-#include "./WebRtcConnection.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(PliPacerHandler, "rtp.PliPacerHandler");
-
-constexpr duration PliPacerHandler::kMinPLIPeriod;
-constexpr duration PliPacerHandler::kKeyframeTimeout;
-
-PliPacerHandler::PliPacerHandler(std::shared_ptr<erizo::Clock> the_clock)
-    : enabled_{true}, connection_{nullptr}, clock_{the_clock}, time_last_keyframe_{clock_->now()},
-      waiting_for_keyframe_{false}, scheduled_pli_{std::make_shared<ScheduledTaskReference>()},
-      video_sink_ssrc_{0}, video_source_ssrc_{0}, fir_seq_number_{0} {}
-
-void PliPacerHandler::enable() {
-  enabled_ = true;
-}
-
-void PliPacerHandler::disable() {
-  enabled_ = false;
-}
-
-void PliPacerHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-    video_sink_ssrc_ = connection_->getVideoSinkSSRC();
-    video_source_ssrc_ = connection_->getVideoSourceSSRC();
-  }
-}
-
-void PliPacerHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (enabled_ && packet->is_keyframe) {
-    time_last_keyframe_ = clock_->now();
-    waiting_for_keyframe_ = false;
-    connection_->getWorker()->unschedule(scheduled_pli_);
-    scheduled_pli_ = std::make_shared<ScheduledTaskReference>();
-  }
-  ctx->fireRead(std::move(packet));
-}
-
-void PliPacerHandler::sendPLI() {
-  getContext()->fireWrite(RtpUtils::createPLI(video_source_ssrc_, video_sink_ssrc_));
-  scheduleNextPLI();
-}
-
-void PliPacerHandler::sendFIR() {
-  ELOG_WARN("%s message: Timed out waiting for a keyframe", connection_->toLog());
-  getContext()->fireWrite(RtpUtils::createFIR(video_source_ssrc_, video_sink_ssrc_, fir_seq_number_++));
-  getContext()->fireWrite(RtpUtils::createFIR(video_source_ssrc_, video_sink_ssrc_, fir_seq_number_++));
-  getContext()->fireWrite(RtpUtils::createFIR(video_source_ssrc_, video_sink_ssrc_, fir_seq_number_++));
-  waiting_for_keyframe_ = false;
-  scheduled_pli_ = std::make_shared<ScheduledTaskReference>();
-}
-
-void PliPacerHandler::scheduleNextPLI() {
-  if (!waiting_for_keyframe_ || !enabled_) {
-    return;
-  }
-  std::weak_ptr<PliPacerHandler> weak_this = shared_from_this();
-  scheduled_pli_ = connection_->getWorker()->scheduleFromNow([weak_this] {
-    if (auto this_ptr = weak_this.lock()) {
-      if (this_ptr->clock_->now() - this_ptr->time_last_keyframe_ >= kKeyframeTimeout) {
-        this_ptr->sendFIR();
-        return;
-      }
-      this_ptr->sendPLI();
-    }
-  }, kMinPLIPeriod);
-}
-
-void PliPacerHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (enabled_ && RtpUtils::isPLI(packet)) {
-    if (waiting_for_keyframe_) {
-      return;
-    }
-    waiting_for_keyframe_ = true;
-    scheduleNextPLI();
-  }
-  ctx->fireWrite(std::move(packet));
-}
-
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/PliPacerHandler.h b/erizo/src/erizo/rtp/PliPacerHandler.h
deleted file mode 100644
index 29559dc..0000000
--- a/erizo/src/erizo/rtp/PliPacerHandler.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_PLIPACERHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_PLIPACERHANDLER_H_
-
-#include <string>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "thread/Worker.h"
-#include "lib/Clock.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class PliPacerHandler: public Handler, public std::enable_shared_from_this<PliPacerHandler> {
-  DECLARE_LOGGER();
-
- public:
-  static constexpr duration kMinPLIPeriod = std::chrono::milliseconds(200);
-  static constexpr duration kKeyframeTimeout = std::chrono::seconds(10);
-
- public:
-  explicit PliPacerHandler(std::shared_ptr<erizo::Clock> the_clock = std::make_shared<SteadyClock>());
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "pli-pacer";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  void scheduleNextPLI();
-  void sendPLI();
-  void sendFIR();
-
- private:
-  bool enabled_;
-  WebRtcConnection* connection_;
-  std::shared_ptr<erizo::Clock> clock_;
-  time_point time_last_keyframe_;
-  bool waiting_for_keyframe_;
-  std::shared_ptr<ScheduledTaskReference> scheduled_pli_;
-  uint32_t video_sink_ssrc_;
-  uint32_t video_source_ssrc_;
-  uint8_t fir_seq_number_;
-};
-
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_PLIPACERHANDLER_H_
diff --git a/erizo/src/erizo/rtp/QualityFilterHandler.cpp b/erizo/src/erizo/rtp/QualityFilterHandler.cpp
deleted file mode 100644
index 306412a..0000000
--- a/erizo/src/erizo/rtp/QualityFilterHandler.cpp
+++ /dev/null
@@ -1,210 +0,0 @@
-#include "rtp/QualityFilterHandler.h"
-
-#include "./WebRtcConnection.h"
-#include "lib/ClockUtils.h"
-#include "rtp/RtpUtils.h"
-#include "rtp/RtpVP8Parser.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(QualityFilterHandler, "rtp.QualityFilterHandler");
-
-constexpr duration kSwitchTimeout = std::chrono::seconds(3);
-
-QualityFilterHandler::QualityFilterHandler()
-  : connection_{nullptr}, enabled_{true}, initialized_{false},
-  receiving_multiple_ssrc_{false}, changing_spatial_layer_{false}, is_scalable_{false},
-  target_spatial_layer_{0},
-  future_spatial_layer_{-1}, target_temporal_layer_{0},
-  video_sink_ssrc_{0}, video_source_ssrc_{0}, last_ssrc_received_{0},
-  max_video_bw_{0}, last_timestamp_sent_{0}, timestamp_offset_{0},
-  time_change_started_{clock::now()}, picture_id_offset_{0}, last_picture_id_sent_{0} {}
-
-void QualityFilterHandler::enable() {
-  enabled_ = true;
-}
-
-void QualityFilterHandler::disable() {
-  enabled_ = false;
-}
-
-void QualityFilterHandler::handleFeedbackPackets(const std::shared_ptr<DataPacket> &packet) {
-  RtpUtils::forEachRRBlock(packet, [this](RtcpHeader *chead) {
-    if (chead->packettype == RTCP_PS_Feedback_PT &&
-          (chead->getBlockCount() == RTCP_PLI_FMT ||
-           chead->getBlockCount() == RTCP_SLI_FMT ||
-           chead->getBlockCount() == RTCP_PLI_FMT)) {
-      sendPLI();
-    }
-  });
-}
-
-void QualityFilterHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (chead->isFeedback() && enabled_ && is_scalable_) {
-    handleFeedbackPackets(packet);
-    return;
-  }
-
-  ctx->fireRead(std::move(packet));
-}
-
-void QualityFilterHandler::checkLayers() {
-  int new_spatial_layer = quality_manager_->getSpatialLayer();
-  if (new_spatial_layer != target_spatial_layer_) {
-    sendPLI();
-    future_spatial_layer_ = new_spatial_layer;
-    changing_spatial_layer_ = true;
-    time_change_started_ = clock::now();
-  }
-  int new_temporal_layer = quality_manager_->getTemporalLayer();
-  target_temporal_layer_ = new_temporal_layer;
-}
-
-bool QualityFilterHandler::checkSSRCChange(uint32_t ssrc) {
-  bool changed = false;
-  if (last_ssrc_received_ != ssrc) {
-    changed = true;
-  }
-  last_ssrc_received_ = ssrc;
-  return changed;
-}
-
-void QualityFilterHandler::sendPLI() {
-  getContext()->fireRead(RtpUtils::createPLI(video_sink_ssrc_, video_source_ssrc_));
-}
-
-void QualityFilterHandler::changeSpatialLayerOnKeyframeReceived(const std::shared_ptr<DataPacket> &packet) {
-  if (future_spatial_layer_ == -1) {
-    return;
-  }
-
-  time_point now = clock::now();
-
-  if (packet->belongsToSpatialLayer(future_spatial_layer_) &&
-      packet->belongsToTemporalLayer(target_temporal_layer_) &&
-      packet->is_keyframe) {
-    target_spatial_layer_ = future_spatial_layer_;
-    future_spatial_layer_ = -1;
-  } else if (now - time_change_started_ > kSwitchTimeout) {
-    sendPLI();
-    target_spatial_layer_ = future_spatial_layer_;
-    future_spatial_layer_ = -1;
-  }
-}
-
-void QualityFilterHandler::detectVideoScalability(const std::shared_ptr<DataPacket> &packet) {
-  if (is_scalable_ || packet->type != VIDEO_PACKET) {
-    return;
-  }
-  if (packet->belongsToTemporalLayer(1) || packet->belongsToSpatialLayer(1)) {
-    is_scalable_ = true;
-    quality_manager_->enable();
-  }
-}
-
-void QualityFilterHandler::updatePictureID(const std::shared_ptr<DataPacket> &packet) {
-  if (packet->codec == "VP8") {
-    RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-    unsigned char* start_buffer = reinterpret_cast<unsigned char*> (packet->data);
-    start_buffer = start_buffer + rtp_header->getHeaderLength();
-    RtpVP8Parser::setVP8PictureID(start_buffer, packet->length - rtp_header->getHeaderLength(), last_picture_id_sent_);
-  }
-}
-
-void QualityFilterHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-
-  detectVideoScalability(packet);
-
-  if (is_scalable_ && !chead->isRtcp() && enabled_ && packet->type == VIDEO_PACKET) {
-    RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-
-    checkLayers();
-
-    uint32_t ssrc = rtp_header->getSSRC();
-    uint16_t sequence_number = rtp_header->getSeqNumber();
-    int picture_id = packet->picture_id;
-
-    if (last_ssrc_received_ != 0 && ssrc != last_ssrc_received_) {
-      receiving_multiple_ssrc_ = true;
-    }
-
-    changeSpatialLayerOnKeyframeReceived(packet);
-
-    if (!packet->belongsToSpatialLayer(target_spatial_layer_)) {
-      if (!receiving_multiple_ssrc_) {
-        translator_.get(sequence_number, true);
-      }
-      return;
-    }
-
-    uint32_t new_timestamp = rtp_header->getTimestamp();
-
-    if (checkSSRCChange(ssrc)) {
-      translator_.reset();
-      if (last_timestamp_sent_ > 0) {
-        timestamp_offset_ = last_timestamp_sent_ - new_timestamp + 1;
-      }
-      if (last_picture_id_sent_ > 0) {
-        picture_id_offset_ = last_picture_id_sent_ - picture_id + 1;
-      }
-    }
-
-    if (!packet->belongsToTemporalLayer(target_temporal_layer_)) {
-      translator_.get(sequence_number, true);
-      return;
-    }
-
-    SequenceNumber sequence_number_info = translator_.get(sequence_number, false);
-    if (sequence_number_info.type != SequenceNumberType::Valid) {
-      return;
-    }
-
-    if (packet->compatible_spatial_layers.back() == target_spatial_layer_ && packet->ending_of_layer_frame) {
-      rtp_header->setMarker(1);
-    }
-
-    rtp_header->setSSRC(video_sink_ssrc_);
-    rtp_header->setSeqNumber(sequence_number_info.output);
-
-    last_timestamp_sent_ = new_timestamp + timestamp_offset_;
-    rtp_header->setTimestamp(last_timestamp_sent_);
-
-    last_picture_id_sent_ = picture_id + picture_id_offset_;
-    updatePictureID(packet);
-  }
-
-  // TODO(javier): Handle SRs and translate Sequence Numbers?
-
-  ctx->fireWrite(packet);
-}
-
-void QualityFilterHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (!pipeline) {
-    return;
-  }
-
-  auto processor = pipeline->getService<RtcpProcessor>();
-
-  if (processor) {
-    max_video_bw_ = processor->getMaxVideoBW();
-  }
-
-  if (initialized_) {
-    return;
-  }
-
-  connection_ = pipeline->getService<WebRtcConnection>().get();
-  if (!connection_) {
-    return;
-  }
-
-  quality_manager_ = pipeline->getService<QualityManager>();
-
-  video_sink_ssrc_ = connection_->getVideoSinkSSRC();
-  video_source_ssrc_ = connection_->getVideoSourceSSRC();
-  initialized_ = true;
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/QualityFilterHandler.h b/erizo/src/erizo/rtp/QualityFilterHandler.h
deleted file mode 100644
index 7267e0f..0000000
--- a/erizo/src/erizo/rtp/QualityFilterHandler.h
+++ /dev/null
@@ -1,70 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_QUALITYFILTERHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_QUALITYFILTERHANDLER_H_
-
-#include <memory>
-#include <string>
-#include <random>
-#include <map>
-
-#include "./logger.h"
-#include "lib/Clock.h"
-#include "pipeline/Handler.h"
-#include "rtp/SequenceNumberTranslator.h"
-#include "rtp/QualityManager.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class QualityFilterHandler: public Handler, public std::enable_shared_from_this<QualityFilterHandler> {
-  DECLARE_LOGGER();
-
-
- public:
-  QualityFilterHandler();
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-     return "quality_filter";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  void sendPLI();
-  void checkLayers();
-  void handleFeedbackPackets(const std::shared_ptr<DataPacket> &packet);
-  bool checkSSRCChange(uint32_t ssrc);
-  void changeSpatialLayerOnKeyframeReceived(const std::shared_ptr<DataPacket> &packet);
-  void detectVideoScalability(const std::shared_ptr<DataPacket> &packet);
-  void updatePictureID(const std::shared_ptr<DataPacket> &packet);
-
- private:
-  std::shared_ptr<QualityManager> quality_manager_;
-  SequenceNumberTranslator translator_;
-  WebRtcConnection *connection_;
-  bool enabled_;
-  bool initialized_;
-  bool receiving_multiple_ssrc_;
-  bool changing_spatial_layer_;
-  bool is_scalable_;
-  int target_spatial_layer_;
-  int future_spatial_layer_;
-  int target_temporal_layer_;
-  uint32_t video_sink_ssrc_;
-  uint32_t video_source_ssrc_;
-  uint32_t last_ssrc_received_;
-  uint32_t max_video_bw_;
-  uint32_t last_timestamp_sent_;
-  uint32_t timestamp_offset_;
-  time_point time_change_started_;
-  int picture_id_offset_;
-  int last_picture_id_sent_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_QUALITYFILTERHANDLER_H_
diff --git a/erizo/src/erizo/rtp/QualityManager.cpp b/erizo/src/erizo/rtp/QualityManager.cpp
index 31a99cf..72d8254 100644
--- a/erizo/src/erizo/rtp/QualityManager.cpp
+++ b/erizo/src/erizo/rtp/QualityManager.cpp
@@ -2,7 +2,7 @@
 #include <memory>
 
 #include "WebRtcConnection.h"
-#include "rtp/LayerDetectorHandler.h"
+// #include "rtp/LayerDetectorHandler.h"
 
 namespace erizo {
 
@@ -35,15 +35,15 @@ void QualityManager::disable() {
 
 void QualityManager::notifyEvent(MediaEventPtr event) {
   if (event->getType() == "LayerInfoChangedEvent") {
-    auto layer_event = std::static_pointer_cast<LayerInfoChangedEvent>(event);
-    video_frame_width_list_ = layer_event->video_frame_width_list;
-    video_frame_height_list_ = layer_event->video_frame_height_list;
-    video_frame_rate_list_ = layer_event->video_frame_rate_list;
+    // auto layer_event = std::static_pointer_cast<LayerInfoChangedEvent>(event);
+    // video_frame_width_list_ = layer_event->video_frame_width_list;
+    // video_frame_height_list_ = layer_event->video_frame_height_list;
+    // video_frame_rate_list_ = layer_event->video_frame_rate_list;
   }
 }
 
 void QualityManager::notifyQualityUpdate() {
-  if (!enabled_) {
+  if (!enabled_ || !getContext()) {
     return;
   }
 
@@ -157,9 +157,11 @@ void QualityManager::selectLayer(bool try_higher_layers) {
     if (below_min_layer || try_higher_layers) {
       slideshow_mode_active_ = below_min_layer;
       ELOG_DEBUG("Slideshow fallback mode %d", slideshow_mode_active_);
-      WebRtcConnection *connection = getContext()->getPipelineShared()->getService<WebRtcConnection>().get();
-      if (connection) {
-        connection->notifyUpdateToHandlers();
+      if (getContext()) {
+        WebRtcConnection *connection = getContext()->getPipelineShared()->getService<WebRtcConnection>().get();
+        if (connection) {
+          connection->notifyUpdateToHandlers();
+        }
       }
     }
   }
@@ -258,7 +260,9 @@ void QualityManager::setTemporalLayer(int temporal_layer) {
 void QualityManager::setPadding(bool enabled) {
   if (padding_enabled_ != enabled) {
     padding_enabled_ = enabled;
-    getContext()->getPipelineShared()->getService<WebRtcConnection>()->notifyUpdateToHandlers();
+    if (getContext()) {
+      getContext()->getPipelineShared()->getService<WebRtcConnection>()->notifyUpdateToHandlers();
+    }
   }
 }
 
diff --git a/erizo/src/erizo/rtp/RtcpProcessorHandler.cpp b/erizo/src/erizo/rtp/RtcpProcessorHandler.cpp
index 7cf6ac9..8c8d424 100644
--- a/erizo/src/erizo/rtp/RtcpProcessorHandler.cpp
+++ b/erizo/src/erizo/rtp/RtcpProcessorHandler.cpp
@@ -43,6 +43,9 @@ void RtcpProcessorHandler::write(Context *ctx, std::shared_ptr<DataPacket> packe
 }
 
 void RtcpProcessorHandler::notifyUpdate() {
+  if (!getContext()) {
+    return;
+  }
   auto pipeline = getContext()->getPipelineShared();
   if (pipeline && !connection_) {
     connection_ = pipeline->getService<WebRtcConnection>().get();
diff --git a/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.cpp b/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.cpp
deleted file mode 100644
index 2b1cf05..0000000
--- a/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.cpp
+++ /dev/null
@@ -1,214 +0,0 @@
-#include "rtp/RtpPaddingGeneratorHandler.h"
-
-#include <algorithm>
-#include <string>
-
-#include "./MediaDefinitions.h"
-#include "./WebRtcConnection.h"
-#include "./RtpUtils.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(RtpPaddingGeneratorHandler, "rtp.RtpPaddingGeneratorHandler");
-
-constexpr duration kStatsPeriod = std::chrono::milliseconds(100);
-constexpr uint8_t kMaxPaddingSize = 255;
-constexpr uint64_t kMinMarkerRate = 3;
-constexpr uint64_t kInitialBitrate = 300000;
-constexpr uint64_t kPaddingBurstSize = 255 * 10;
-
-RtpPaddingGeneratorHandler::RtpPaddingGeneratorHandler(std::shared_ptr<erizo::Clock> the_clock) :
-  clock_{the_clock}, connection_{nullptr}, max_video_bw_{0}, higher_sequence_number_{0},
-  video_sink_ssrc_{0}, audio_source_ssrc_{0},
-  number_of_full_padding_packets_{0}, last_padding_packet_size_{0},
-  last_rate_calculation_time_{clock_->now()}, started_at_{clock_->now()},
-  enabled_{false}, first_packet_received_{false},
-  marker_rate_{std::chrono::milliseconds(100), 20, 1., clock_},
-  rtp_header_length_{12},
-  bucket_{kInitialBitrate, kPaddingBurstSize, clock_},
-  scheduled_task_{std::make_shared<ScheduledTaskReference>()} {}
-
-
-
-void RtpPaddingGeneratorHandler::enable() {
-}
-
-void RtpPaddingGeneratorHandler::disable() {
-}
-
-void RtpPaddingGeneratorHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-    video_sink_ssrc_ = connection_->getVideoSinkSSRC();
-    audio_source_ssrc_ = connection_->getAudioSinkSSRC();
-    stats_ = pipeline->getService<Stats>();
-    stats_->getNode()["total"].insertStat("paddingBitrate",
-        MovingIntervalRateStat{std::chrono::milliseconds(100), 30, 8., clock_});
-  }
-
-  auto quality_manager = pipeline->getService<QualityManager>();
-
-  if (quality_manager->isPaddingEnabled() && !enabled_) {
-    enablePadding();
-  } else if (!quality_manager->isPaddingEnabled() && enabled_) {
-    disablePadding();
-  }
-
-  auto processor = pipeline->getService<RtcpProcessor>();
-  if (processor) {
-    max_video_bw_ = processor->getMaxVideoBW();
-  }
-}
-
-void RtpPaddingGeneratorHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  ctx->fireRead(std::move(packet));
-}
-
-void RtpPaddingGeneratorHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  bool is_higher_sequence_number = false;
-  if (packet->type == VIDEO_PACKET && !chead->isRtcp()) {
-    connection_->getWorker()->unschedule(scheduled_task_);
-    is_higher_sequence_number = isHigherSequenceNumber(packet);
-    if (!first_packet_received_) {
-      started_at_ = clock_->now();
-    }
-    first_packet_received_ = true;
-  }
-
-  ctx->fireWrite(packet);
-
-  if (is_higher_sequence_number) {
-    onVideoPacket(std::move(packet));
-  }
-}
-
-void RtpPaddingGeneratorHandler::sendPaddingPacket(std::shared_ptr<DataPacket> packet, uint8_t padding_size) {
-  if (padding_size == 0) {
-    return;
-  }
-
-  if (!bucket_.consume(padding_size)) {
-    return;
-  }
-
-  SequenceNumber sequence_number = translator_.generate();
-
-  auto padding_packet = RtpUtils::makePaddingPacket(packet, padding_size);
-
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(padding_packet->data);
-
-  rtp_header->setSeqNumber(sequence_number.output);
-  stats_->getNode()["total"]["paddingBitrate"] += padding_packet->length;
-  getContext()->fireWrite(std::move(padding_packet));
-}
-
-void RtpPaddingGeneratorHandler::onPacketWithMarkerSet(std::shared_ptr<DataPacket> packet) {
-  marker_rate_++;
-
-  for (uint i = 0; i < number_of_full_padding_packets_; i++) {
-    sendPaddingPacket(packet, kMaxPaddingSize);
-  }
-  sendPaddingPacket(packet, last_padding_packet_size_);
-  std::weak_ptr<RtpPaddingGeneratorHandler> weak_this = shared_from_this();
-  scheduled_task_ = connection_->getWorker()->scheduleFromNow([packet, weak_this] {
-    if (auto this_ptr = weak_this.lock()) {
-      this_ptr->onPacketWithMarkerSet(packet);
-    }
-  }, std::chrono::milliseconds(1000 / kMinMarkerRate));
-}
-
-bool RtpPaddingGeneratorHandler::isHigherSequenceNumber(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  rtp_header_length_ = rtp_header->getHeaderLength();
-  uint16_t new_sequence_number = rtp_header->getSeqNumber();
-  SequenceNumber sequence_number = translator_.get(new_sequence_number, false);
-  rtp_header->setSeqNumber(sequence_number.output);
-  if (first_packet_received_ && RtpUtils::sequenceNumberLessThan(new_sequence_number, higher_sequence_number_)) {
-    return false;
-  }
-  higher_sequence_number_ = new_sequence_number;
-  return true;
-}
-
-void RtpPaddingGeneratorHandler::onVideoPacket(std::shared_ptr<DataPacket> packet) {
-  if (!enabled_) {
-    return;
-  }
-
-  recalculatePaddingRate();
-
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  if (rtp_header->getMarker()) {
-    onPacketWithMarkerSet(std::move(packet));
-  }
-}
-
-uint64_t RtpPaddingGeneratorHandler::getStat(std::string stat_name) {
-  if (stats_->getNode()[video_sink_ssrc_].hasChild(stat_name)) {
-    StatNode & stat = stats_->getNode()[video_sink_ssrc_][stat_name];
-    return static_cast<MovingIntervalRateStat&>(stat).value();
-  }
-  return 0;
-}
-
-bool RtpPaddingGeneratorHandler::isTimeToCalculateBitrate() {
-  return (clock_->now() - last_rate_calculation_time_) >= kStatsPeriod;
-}
-
-void RtpPaddingGeneratorHandler::recalculatePaddingRate() {
-  if (!isTimeToCalculateBitrate()) {
-    return;
-  }
-
-  last_rate_calculation_time_ = clock_->now();
-
-  int64_t total_bitrate = getStat("bitrateCalculated");
-  int64_t padding_bitrate = stats_->getNode()["total"]["paddingBitrate"].value();
-  int64_t media_bitrate = std::max(total_bitrate - padding_bitrate, int64_t(0));
-
-  uint64_t target_bitrate = getTargetBitrate();
-
-  int64_t target_padding_bitrate = target_bitrate - media_bitrate;
-  // TODO(pedro): figure out a burst size that makes sense here
-  bucket_.reset(std::max(target_padding_bitrate, int64_t(0)), kPaddingBurstSize);
-
-  if (target_padding_bitrate <= 0) {
-    number_of_full_padding_packets_ = 0;
-    last_padding_packet_size_ = 0;
-    return;
-  }
-
-  uint64_t marker_rate = marker_rate_.value(std::chrono::milliseconds(500));
-  marker_rate = std::max(marker_rate, kMinMarkerRate);
-  uint64_t bytes_per_marker = target_padding_bitrate / (marker_rate * 8);
-  number_of_full_padding_packets_ = bytes_per_marker / (kMaxPaddingSize + rtp_header_length_);
-  last_padding_packet_size_ = bytes_per_marker % (kMaxPaddingSize + rtp_header_length_) - rtp_header_length_;
-}
-
-uint64_t RtpPaddingGeneratorHandler::getTargetBitrate() {
-  uint64_t target_bitrate = kInitialBitrate;
-
-  if (stats_->getNode()["total"].hasChild("senderBitrateEstimation")) {
-    target_bitrate = static_cast<CumulativeStat&>(stats_->getNode()["total"]["senderBitrateEstimation"]).value();
-  }
-
-  if (max_video_bw_ > 0) {
-    target_bitrate = std::min(target_bitrate, max_video_bw_);
-  }
-  return target_bitrate;
-}
-
-void RtpPaddingGeneratorHandler::enablePadding() {
-  enabled_ = true;
-  number_of_full_padding_packets_ = 0;
-  last_padding_packet_size_ = 0;
-  last_rate_calculation_time_ = clock_->now();
-}
-
-void RtpPaddingGeneratorHandler::disablePadding() {
-  enabled_ = false;
-}
-
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.h b/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.h
deleted file mode 100644
index 4ac3bf3..0000000
--- a/erizo/src/erizo/rtp/RtpPaddingGeneratorHandler.h
+++ /dev/null
@@ -1,73 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_RTPPADDINGGENERATORHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_RTPPADDINGGENERATORHANDLER_H_
-
-#include <string>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "lib/Clock.h"
-#include "lib/TokenBucket.h"
-#include "thread/Worker.h"
-#include "rtp/SequenceNumberTranslator.h"
-#include "./Stats.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class RtpPaddingGeneratorHandler: public Handler, public std::enable_shared_from_this<RtpPaddingGeneratorHandler> {
-  DECLARE_LOGGER();
-
- public:
-  explicit RtpPaddingGeneratorHandler(std::shared_ptr<erizo::Clock> the_clock = std::make_shared<erizo::SteadyClock>());
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "padding-generator";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  void sendPaddingPacket(std::shared_ptr<DataPacket> packet, uint8_t padding_size);
-  void onPacketWithMarkerSet(std::shared_ptr<DataPacket> packet);
-  bool isHigherSequenceNumber(std::shared_ptr<DataPacket> packet);
-  void onVideoPacket(std::shared_ptr<DataPacket> packet);
-
-  uint64_t getStat(std::string stat_name);
-  uint64_t getTargetBitrate();
-
-  bool isTimeToCalculateBitrate();
-  void recalculatePaddingRate();
-
-  void enablePadding();
-  void disablePadding();
-
- private:
-  std::shared_ptr<erizo::Clock> clock_;
-  SequenceNumberTranslator translator_;
-  WebRtcConnection* connection_;
-  std::shared_ptr<Stats> stats_;
-  uint64_t max_video_bw_;
-  uint16_t higher_sequence_number_;
-  uint32_t video_sink_ssrc_;
-  uint32_t audio_source_ssrc_;
-  uint64_t number_of_full_padding_packets_;
-  uint8_t last_padding_packet_size_;
-  time_point last_rate_calculation_time_;
-  time_point started_at_;
-  bool enabled_;
-  bool first_packet_received_;
-  MovingIntervalRateStat marker_rate_;
-  uint32_t rtp_header_length_;
-  TokenBucket bucket_;
-  std::shared_ptr<ScheduledTaskReference> scheduled_task_;
-};
-
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_RTPPADDINGGENERATORHANDLER_H_
diff --git a/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.cpp b/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.cpp
deleted file mode 100644
index e878a0f..0000000
--- a/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.cpp
+++ /dev/null
@@ -1,133 +0,0 @@
-#include "rtp/RtpPaddingRemovalHandler.h"
-#include "rtp/RtpUtils.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(RtpPaddingRemovalHandler, "rtp.RtpPaddingRemovalHandler");
-
-RtpPaddingRemovalHandler::RtpPaddingRemovalHandler()
-  : enabled_{true}, initialized_{false} {}
-
-void RtpPaddingRemovalHandler::enable() {
-  enabled_ = true;
-}
-
-void RtpPaddingRemovalHandler::disable() {
-  enabled_ = false;
-}
-
-void RtpPaddingRemovalHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-
-  if (!chead->isRtcp() && enabled_ && packet->type == VIDEO_PACKET) {
-    uint32_t ssrc = rtp_header->getSSRC();
-    std::shared_ptr<SequenceNumberTranslator> translator = getTranslatorForSsrc(ssrc, true);
-    if (!removePaddingBytes(packet, translator)) {
-      return;
-    }
-    uint16_t sequence_number = rtp_header->getSeqNumber();
-    SequenceNumber sequence_number_info = translator->get(sequence_number, false);
-
-    if (sequence_number_info.type != SequenceNumberType::Valid) {
-      ELOG_DEBUG("Invalid translation %u, ssrc: %u", sequence_number, ssrc);
-      return;
-    }
-    ELOG_DEBUG("Changing seq_number from %u to %u, ssrc %u", sequence_number, sequence_number_info.output,
-     ssrc);
-    rtp_header->setSeqNumber(sequence_number_info.output);
-  }
-  ctx->fireRead(std::move(packet));
-}
-
-void RtpPaddingRemovalHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader* rtcp_head = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (!enabled_ || packet->type != VIDEO_PACKET || !rtcp_head->isFeedback()) {
-    ctx->fireWrite(std::move(packet));
-    return;
-  }
-  uint32_t ssrc = rtcp_head->getSourceSSRC();
-  std::shared_ptr<SequenceNumberTranslator> translator = getTranslatorForSsrc(ssrc, false);
-  if (!translator) {
-    ELOG_DEBUG("No translator for ssrc %u, %s", ssrc, connection_->toLog());
-    ctx->fireWrite(std::move(packet));
-    return;
-  }
-  RtpUtils::forEachRRBlock(packet, [this, translator, ssrc](RtcpHeader *chead) {
-    if (chead->packettype == RTCP_RTP_Feedback_PT) {
-      RtpUtils::forEachNack(chead, [this, chead, translator, ssrc](uint16_t new_seq_num, uint16_t new_plb,
-      RtcpHeader* nack_header) {
-        uint16_t initial_seq_num = new_seq_num;
-        std::vector<uint16_t> seq_nums;
-        for (int i = -1; i <= 15; i++) {
-          uint16_t seq_num = initial_seq_num + i + 1;
-          SequenceNumber input_seq_num = translator->reverse(seq_num);
-          if (input_seq_num.type == SequenceNumberType::Valid) {
-            seq_nums.push_back(input_seq_num.input);
-          } else {
-            ELOG_DEBUG("Input is not valid for %u, ssrc %u, %s", seq_num, ssrc, connection_->toLog());
-          }
-          ELOG_DEBUG("Lost packet %u, input %u, ssrc %u", seq_num, input_seq_num.input, ssrc);
-        }
-        if (seq_nums.size() > 0) {
-          uint16_t pid = seq_nums[0];
-          uint16_t blp = 0;
-          for (uint16_t index = 1; index < seq_nums.size() ; index++) {
-            uint16_t distance = seq_nums[index] - pid - 1;
-            blp |= (1 << distance);
-          }
-          nack_header->setNackPid(pid);
-          nack_header->setNackBlp(blp);
-          ELOG_DEBUG("Translated pid %u, translated blp %u, ssrc %u, %s", pid, blp, ssrc, connection_->toLog());
-        }
-      });
-    }
-  });
-  ctx->fireWrite(std::move(packet));
-}
-
-bool RtpPaddingRemovalHandler::removePaddingBytes(std::shared_ptr<DataPacket> packet,
-    std::shared_ptr<SequenceNumberTranslator> translator) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  int header_length = rtp_header->getHeaderLength();
-
-  int padding_length = RtpUtils::getPaddingLength(packet);
-  if (padding_length + header_length == packet->length) {
-    uint16_t sequence_number = rtp_header->getSeqNumber();
-    translator->get(sequence_number, true);
-    ELOG_DEBUG("Dropping packet %u, %s", sequence_number, connection_->toLog());
-    return false;
-  }
-  packet->length -= padding_length;
-  rtp_header->padding = 0;
-  return true;
-}
-
-std::shared_ptr<SequenceNumberTranslator> RtpPaddingRemovalHandler::getTranslatorForSsrc(uint32_t ssrc,
-  bool should_create) {
-    auto translator_it = translator_map_.find(ssrc);
-    std::shared_ptr<SequenceNumberTranslator> translator;
-    if (translator_it != translator_map_.end()) {
-      ELOG_DEBUG("Found Translator for %u, %s", ssrc, connection_->toLog());
-      translator = translator_it->second;
-    } else if (should_create) {
-      ELOG_DEBUG("message: no Translator found creating a new one, ssrc: %u, %s", ssrc,
-      connection_->toLog());
-      translator = std::make_shared<SequenceNumberTranslator>();
-      translator_map_[ssrc] = translator;
-    }
-    return translator;
-  }
-
-void RtpPaddingRemovalHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (!pipeline) {
-    return;
-  }
-  if (initialized_) {
-    return;
-  }
-  connection_ = pipeline->getService<WebRtcConnection>().get();
-  initialized_ = true;
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.h b/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.h
deleted file mode 100644
index 2847440..0000000
--- a/erizo/src/erizo/rtp/RtpPaddingRemovalHandler.h
+++ /dev/null
@@ -1,48 +0,0 @@
-
-#ifndef ERIZO_SRC_ERIZO_RTP_RTPPADDINGREMOVALHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_RTPPADDINGREMOVALHANDLER_H_
-
-#include <map>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-#include "rtp/SequenceNumberTranslator.h"
-#include "WebRtcConnection.h"
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class RtpPaddingRemovalHandler: public Handler, public std::enable_shared_from_this<RtpPaddingRemovalHandler> {
-  DECLARE_LOGGER();
-
-
- public:
-  RtpPaddingRemovalHandler();
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-     return "padding_removal";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  bool removePaddingBytes(std::shared_ptr<DataPacket> packet,
-      std::shared_ptr<SequenceNumberTranslator> translator);
-  std::shared_ptr<SequenceNumberTranslator> getTranslatorForSsrc(uint32_t ssrc,
-    bool should_create);
-
- private:
-  bool enabled_;
-  bool initialized_;
-  std::map<uint32_t, std::shared_ptr<SequenceNumberTranslator>> translator_map_;
-  WebRtcConnection* connection_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_RTPPADDINGREMOVALHANDLER_H_
diff --git a/erizo/src/erizo/rtp/RtpRetransmissionHandler.cpp b/erizo/src/erizo/rtp/RtpRetransmissionHandler.cpp
index 47ea198..d4e4f62 100644
--- a/erizo/src/erizo/rtp/RtpRetransmissionHandler.cpp
+++ b/erizo/src/erizo/rtp/RtpRetransmissionHandler.cpp
@@ -15,7 +15,10 @@ RtpRetransmissionHandler::RtpRetransmissionHandler(std::shared_ptr<erizo::Clock>
     connection_{nullptr},
     initialized_{false}, enabled_{true},
     bucket_{static_cast<uint64_t>(kDefaultBitrate * kMarginRtxBitrate), kBurstSize, clock_},
-    last_bitrate_time_{clock_->now()} {}
+    last_bitrate_time_{} {
+  if (clock_)
+    last_bitrate_time_ = clock_->now();
+}
 
 
 void RtpRetransmissionHandler::enable() {
@@ -27,6 +30,9 @@ void RtpRetransmissionHandler::disable() {
 }
 
 void RtpRetransmissionHandler::notifyUpdate() {
+  if (!getContext())
+    return;
+
   auto pipeline = getContext()->getPipelineShared();
   if (pipeline && !connection_) {
     connection_ = pipeline->getService<WebRtcConnection>().get();
@@ -99,7 +105,8 @@ void RtpRetransmissionHandler::read(Context *ctx, std::shared_ptr<DataPacket> pa
             RtpHeader *recovered_head = reinterpret_cast<RtpHeader*> (recovered->data);
             if (recovered_head->getSeqNumber() == seq_num) {
               getRtxBitrateStat() += recovered->length;
-              getContext()->fireWrite(recovered);
+              if (getContext())
+                getContext()->fireWrite(recovered);
               continue;
             }
           }
diff --git a/erizo/src/erizo/rtp/RtpSlideShowHandler.cpp b/erizo/src/erizo/rtp/RtpSlideShowHandler.cpp
deleted file mode 100644
index 66bbff8..0000000
--- a/erizo/src/erizo/rtp/RtpSlideShowHandler.cpp
+++ /dev/null
@@ -1,263 +0,0 @@
-#include "rtp/RtpSlideShowHandler.h"
-
-#include <vector>
-
-#include "./MediaDefinitions.h"
-#include "rtp/RtpUtils.h"
-
-
-namespace erizo {
-
-DEFINE_LOGGER(RtpSlideShowHandler, "rtp.RtpSlideShowHandler");
-
-RtpSlideShowHandler::RtpSlideShowHandler(std::shared_ptr<Clock> the_clock)
-  : clock_{the_clock}, connection_{nullptr}, highest_seq_num_initialized_{false},
-    is_building_keyframe_ {false},
-    highest_seq_num_ {0},
-    packets_received_while_building_{0},
-    first_keyframe_seq_num_{0},
-    slideshow_is_active_{false},
-    current_keyframe_timestamp_{0},
-    last_timestamp_received_{0},
-    keyframe_buffer_{kMaxKeyframeSize},
-    last_keyframe_sent_time_{clock_->now()} {}
-
-
-void RtpSlideShowHandler::enable() {
-}
-
-void RtpSlideShowHandler::disable() {
-}
-
-void RtpSlideShowHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-  }
-  bool fallback_slideshow_enabled = pipeline->getService<QualityManager>()->isSlideShowEnabled();
-  bool manual_slideshow_enabled = connection_->isSlideShowModeEnabled();
-  if (fallback_slideshow_enabled) {
-    ELOG_DEBUG("Slideshow fallback mode enabled");
-  } else {
-    ELOG_DEBUG("Slideshow fallback mode disabled");
-  }
-  setSlideShowMode(fallback_slideshow_enabled || manual_slideshow_enabled);
-}
-
-void RtpSlideShowHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (connection_->getVideoSinkSSRC() != chead->getSourceSSRC()) {
-    ctx->fireRead(std::move(packet));
-    return;
-  }
-  RtpUtils::forEachRRBlock(packet, [this](RtcpHeader *chead) {
-    switch (chead->packettype) {
-      case RTCP_Receiver_PT:
-        {
-          uint16_t incoming_seq_num = chead->getHighestSeqnum();
-          SequenceNumber input_seq_num = translator_.reverse(incoming_seq_num);
-          if (input_seq_num.type != SequenceNumberType::Valid) {
-            break;
-          }
-          if (RtpUtils::sequenceNumberLessThan(input_seq_num.input, incoming_seq_num)) {
-            chead->setSeqnumCycles(chead->getSeqnumCycles() - 1);
-          }
-
-          chead->setHighestSeqnum(input_seq_num.input);
-          break;
-        }
-      case RTCP_RTP_Feedback_PT:
-        {
-          SequenceNumber input_seq_num = translator_.reverse(chead->getNackPid());
-          if (input_seq_num.type == SequenceNumberType::Valid) {
-            chead->setNackPid(input_seq_num.input);
-          }
-          break;
-        }
-      default:
-        break;
-    }
-  });
-  ctx->fireRead(std::move(packet));
-}
-
-void RtpSlideShowHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  RtcpHeader *rtcp_header = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (packet->type != VIDEO_PACKET || rtcp_header->isRtcp()) {
-    ctx->fireWrite(std::move(packet));
-    return;
-  }
-  bool should_skip_packet = false;
-
-  last_timestamp_received_ = rtp_header->getTimestamp();
-
-  uint16_t packet_seq_num = rtp_header->getSeqNumber();
-  bool is_keyframe = false;
-  RtpMap *codec = connection_->getRemoteSdpInfo().getCodecByExternalPayloadType(rtp_header->getPayloadType());
-  if (codec && (codec->encoding_name == "VP8" || codec->encoding_name == "H264")) {
-    is_keyframe = isVP8Keyframe(packet);
-  } else if (codec && codec->encoding_name == "VP9") {
-    is_keyframe = isVP9Keyframe(packet);
-  }
-  if (slideshow_is_active_) {
-    should_skip_packet = !is_keyframe;
-
-    if (is_keyframe) {
-      storeKeyframePacket(packet);
-    }
-
-    if (is_building_keyframe_) {
-      consolidateKeyframe();
-    }
-    maybeSendStoredKeyframe();
-  }
-  maybeUpdateHighestSeqNum(rtp_header->getSeqNumber());
-  SequenceNumber sequence_number_info = translator_.get(packet_seq_num, should_skip_packet);
-  if (!should_skip_packet && sequence_number_info.type == SequenceNumberType::Valid) {
-    rtp_header->setSeqNumber(sequence_number_info.output);
-    ELOG_DEBUG("SN %u %d", sequence_number_info.output, is_keyframe);
-    last_keyframe_sent_time_ = clock_->now();
-    ctx->fireWrite(std::move(packet));
-  }
-}
-
-bool RtpSlideShowHandler::isVP8Keyframe(std::shared_ptr<DataPacket> packet) {
-  bool is_keyframe = false;
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  uint16_t seq_num = rtp_header->getSeqNumber();
-  uint32_t timestamp = rtp_header->getTimestamp();
-
-  if (packet->is_keyframe &&
-      (RtpUtils::sequenceNumberLessThan(highest_seq_num_, seq_num) || !highest_seq_num_initialized_)) {
-    is_keyframe = true;
-    current_keyframe_timestamp_ = timestamp;
-
-    resetKeyframeBuilding();
-    is_building_keyframe_ = true;
-    first_keyframe_seq_num_ = seq_num;
-  } else if (timestamp == current_keyframe_timestamp_) {
-    is_keyframe = true;
-  }
-
-  return is_keyframe;
-}
-
-bool RtpSlideShowHandler::isVP9Keyframe(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  uint16_t seq_num = rtp_header->getSeqNumber();
-  uint32_t timestamp = rtp_header->getTimestamp();
-
-  if (packet->is_keyframe) {
-    if (RtpUtils::sequenceNumberLessThan(seq_num, first_keyframe_seq_num_)) {
-      first_keyframe_seq_num_ = seq_num;
-      for (uint16_t index = seq_num; index < first_keyframe_seq_num_; index++) {
-        keyframe_buffer_.push_back(std::shared_ptr<DataPacket>{});
-      }
-    }
-    if (timestamp != current_keyframe_timestamp_) {
-      resetKeyframeBuilding();
-      first_keyframe_seq_num_ = seq_num;
-      current_keyframe_timestamp_ = timestamp;
-      is_building_keyframe_ = true;
-    }
-  }
-
-  return packet->is_keyframe;
-}
-
-void RtpSlideShowHandler::storeKeyframePacket(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  uint16_t index = rtp_header->getSeqNumber() - first_keyframe_seq_num_;
-  if (index < keyframe_buffer_.size()) {
-    keyframe_buffer_[index] = packet;
-  }
-}
-
-void RtpSlideShowHandler::setSlideShowMode(bool active) {
-  if (slideshow_is_active_ == active) {
-    return;
-  }
-
-  last_keyframe_sent_time_ = clock_->now();
-  resetKeyframeBuilding();
-
-  if (active) {
-    slideshow_is_active_ = true;
-    getContext()->fireRead(RtpUtils::createPLI(connection_->getVideoSinkSSRC(), connection_->getVideoSourceSSRC()));
-    connection_->setFeedbackReports(false, 0);
-  } else {
-    slideshow_is_active_ = false;
-    connection_->setFeedbackReports(true, 0);
-    getContext()->fireRead(RtpUtils::createPLI(connection_->getVideoSinkSSRC(), connection_->getVideoSourceSSRC()));
-  }
-}
-
-void RtpSlideShowHandler::maybeUpdateHighestSeqNum(uint16_t seq_num) {
-  if (RtpUtils::sequenceNumberLessThan(highest_seq_num_, seq_num) || !highest_seq_num_initialized_) {
-    highest_seq_num_ = seq_num;
-    highest_seq_num_initialized_ = true;
-  }
-}
-
-void RtpSlideShowHandler::resetKeyframeBuilding() {
-  packets_received_while_building_ = 0;
-  first_keyframe_seq_num_ = 0;
-  is_building_keyframe_ = false;
-  keyframe_buffer_.clear();
-  keyframe_buffer_.resize(kMaxKeyframeSize);
-}
-
-void RtpSlideShowHandler::consolidateKeyframe() {
-  if (packets_received_while_building_++ > kMaxKeyframeSize) {
-    resetKeyframeBuilding();
-    return;
-  }
-  std::shared_ptr<DataPacket> packet;
-  bool keyframe_complete = false;
-  std::vector<std::shared_ptr<DataPacket>> temp_keyframe;
-
-  for (int seq_num = 0; seq_num < kMaxKeyframeSize; seq_num++) {
-    packet = keyframe_buffer_[seq_num];
-    if (!packet) {
-      break;
-    }
-    RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-    uint32_t timestamp = rtp_header->getTimestamp();
-
-    if (timestamp != current_keyframe_timestamp_) {
-      break;
-    }
-
-    temp_keyframe.push_back(packet);
-    if (rtp_header->getMarker()) {
-      //  todo(javier): keyframe may not be complete in VP9 if packet is marker and we have lost packets before
-      keyframe_complete = true;
-      break;
-    }
-  }
-
-  if (keyframe_complete) {
-    stored_keyframe_.swap(temp_keyframe);
-    resetKeyframeBuilding();
-    ELOG_DEBUG("Keyframe consolidated");
-  }
-}
-
-void RtpSlideShowHandler::maybeSendStoredKeyframe() {
-  time_point now = clock_->now();
-  if (now - last_keyframe_sent_time_ > kFallbackKeyframeTimeout) {
-    if (stored_keyframe_.size() > 0) {
-      ELOG_DEBUG("Keyframe sent");
-    }
-    for (auto packet : stored_keyframe_) {
-      RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-      rtp_header->setTimestamp(last_timestamp_received_);
-      SequenceNumber sequence_number = translator_.generate();
-      rtp_header->setSeqNumber(sequence_number.output);
-      getContext()->fireWrite(packet);
-    }
-    last_keyframe_sent_time_ = now;
-  }
-}
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/RtpSlideShowHandler.h b/erizo/src/erizo/rtp/RtpSlideShowHandler.h
deleted file mode 100644
index e07b0d5..0000000
--- a/erizo/src/erizo/rtp/RtpSlideShowHandler.h
+++ /dev/null
@@ -1,66 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_RTPSLIDESHOWHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_RTPSLIDESHOWHANDLER_H_
-
-#include <string>
-
-#include "pipeline/Handler.h"
-#include "./logger.h"
-#include "./WebRtcConnection.h"
-#include "rtp/SequenceNumberTranslator.h"
-#include "rtp/PacketBufferService.h"
-#include "rtp/RtpVP8Parser.h"
-#include "rtp/RtpVP9Parser.h"
-#include "lib/ClockUtils.h"
-
-static constexpr uint16_t kMaxKeyframeSize = 20;
-static constexpr erizo::duration kFallbackKeyframeTimeout = std::chrono::seconds(5);
-
-namespace erizo {
-class RtpSlideShowHandler : public Handler {
-  DECLARE_LOGGER();
-
- public:
-  explicit RtpSlideShowHandler(std::shared_ptr<Clock> the_clock = std::make_shared<SteadyClock>());
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "slideshow";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
-  void setSlideShowMode(bool activated);
-
- private:
-  bool isVP8Keyframe(std::shared_ptr<DataPacket> packet);
-  bool isVP9Keyframe(std::shared_ptr<DataPacket> packet);
-  void maybeUpdateHighestSeqNum(uint16_t seq_num);
-  void resetKeyframeBuilding();
-  void consolidateKeyframe();
-  void maybeSendStoredKeyframe();
-  void storeKeyframePacket(std::shared_ptr<DataPacket> packet);
-
- private:
-  std::shared_ptr<Clock> clock_;
-  WebRtcConnection* connection_;
-  SequenceNumberTranslator translator_;
-  bool highest_seq_num_initialized_;
-  bool is_building_keyframe_;
-  uint16_t  highest_seq_num_;
-  uint16_t packets_received_while_building_;
-  uint16_t first_keyframe_seq_num_;
-  bool slideshow_is_active_;
-  uint32_t current_keyframe_timestamp_;
-  uint32_t last_timestamp_received_;
-
-  std::vector<std::shared_ptr<DataPacket>> keyframe_buffer_;
-  std::vector<std::shared_ptr<DataPacket>> stored_keyframe_;
-  time_point last_keyframe_sent_time_;
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_RTPSLIDESHOWHANDLER_H_
diff --git a/erizo/src/erizo/rtp/RtpTrackMuteHandler.cpp b/erizo/src/erizo/rtp/RtpTrackMuteHandler.cpp
deleted file mode 100644
index 92bd1d2..0000000
--- a/erizo/src/erizo/rtp/RtpTrackMuteHandler.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-#include "rtp/RtpTrackMuteHandler.h"
-#include "./MediaDefinitions.h"
-#include "./WebRtcConnection.h"
-#include "rtp/RtpUtils.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(RtpTrackMuteHandler, "rtp.RtpTrackMuteHandler");
-
-RtpTrackMuteHandler::RtpTrackMuteHandler() : audio_info_{"audio"}, video_info_{"video"}, connection_{nullptr} {}
-
-void RtpTrackMuteHandler::enable() {
-}
-
-void RtpTrackMuteHandler::disable() {
-}
-
-void RtpTrackMuteHandler::notifyUpdate() {
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-  }
-  muteTrack(&audio_info_, connection_->isAudioMuted());
-  muteTrack(&video_info_, connection_->isVideoMuted());
-}
-
-void RtpTrackMuteHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-
-  if (connection_->getAudioSinkSSRC() == chead->getSourceSSRC()) {
-    handleFeedback(audio_info_, packet);
-  } else if (connection_->getVideoSinkSSRC() == chead->getSourceSSRC()) {
-    handleFeedback(video_info_, packet);
-  }
-
-  ctx->fireRead(std::move(packet));
-}
-
-void RtpTrackMuteHandler::handleFeedback(const TrackMuteInfo &info, const std::shared_ptr<DataPacket> &packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  uint16_t offset = info.seq_num_offset;
-  if (offset > 0) {
-    char* buf = packet->data;
-    char* report_pointer = buf;
-    int rtcp_length = 0;
-    int total_length = 0;
-    do {
-      report_pointer += rtcp_length;
-      chead = reinterpret_cast<RtcpHeader*>(report_pointer);
-      rtcp_length = (ntohs(chead->length) + 1) * 4;
-      total_length += rtcp_length;
-      switch (chead->packettype) {
-        case RTCP_Receiver_PT:
-          if ((chead->getHighestSeqnum() + offset) < chead->getHighestSeqnum()) {
-            // The seqNo adjustment causes a wraparound, add to cycles
-            chead->setSeqnumCycles(chead->getSeqnumCycles() + 1);
-          }
-          chead->setHighestSeqnum(chead->getHighestSeqnum() + offset);
-
-          break;
-        case RTCP_RTP_Feedback_PT:
-          chead->setNackPid(chead->getNackPid() + offset);
-          break;
-        default:
-          break;
-      }
-    } while (total_length < packet->length);
-  }
-}
-
-void RtpTrackMuteHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *rtcp_header = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (rtcp_header->isRtcp()) {
-    ctx->fireWrite(std::move(packet));
-  } else if (packet->type == AUDIO_PACKET) {
-    handlePacket(ctx, &audio_info_, std::move(packet));
-  } else if (packet->type == VIDEO_PACKET) {
-    handlePacket(ctx, &video_info_, std::move(packet));
-  } else {
-    ctx->fireWrite(std::move(packet));
-  }
-}
-
-void RtpTrackMuteHandler::handlePacket(Context *ctx, TrackMuteInfo *info, std::shared_ptr<DataPacket> packet) {
-  RtpHeader *rtp_header = reinterpret_cast<RtpHeader*>(packet->data);
-  uint16_t offset = info->seq_num_offset;
-  info->last_original_seq_num = rtp_header->getSeqNumber();
-  if (!info->mute_is_active) {
-    info->last_sent_seq_num = info->last_original_seq_num - offset;
-    if (offset > 0) {
-      setPacketSeqNumber(packet, info->last_sent_seq_num);
-    }
-    ctx->fireWrite(std::move(packet));
-  }
-}
-
-void RtpTrackMuteHandler::muteAudio(bool active) {
-  muteTrack(&audio_info_, active);
-}
-
-void RtpTrackMuteHandler::muteVideo(bool active) {
-  muteTrack(&video_info_, active);
-}
-
-void RtpTrackMuteHandler::muteTrack(TrackMuteInfo *info, bool active) {
-  if (info->mute_is_active == active) {
-    return;
-  }
-  info->mute_is_active = active;
-  ELOG_INFO("%s message: Mute %s, active: %d", info->label.c_str(), connection_->toLog(), active);
-  if (!info->mute_is_active) {
-    info->seq_num_offset = info->last_original_seq_num - info->last_sent_seq_num;
-    ELOG_DEBUG("%s message: Deactivated, original_seq_num: %u, last_sent_seq_num: %u, offset: %u",
-        connection_->toLog(), info->last_original_seq_num, info->last_sent_seq_num, info->seq_num_offset);
-  } else {
-    if (info->label == "video") {
-      getContext()->fireRead(RtpUtils::createPLI(connection_->getVideoSinkSSRC(), connection_->getVideoSourceSSRC()));
-    }
-  }
-}
-
-inline void RtpTrackMuteHandler::setPacketSeqNumber(std::shared_ptr<DataPacket> packet, uint16_t seq_number) {
-  RtpHeader *head = reinterpret_cast<RtpHeader*> (packet->data);
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*> (packet->data);
-  if (chead->isRtcp()) {
-    return;
-  }
-  head->setSeqNumber(seq_number);
-}
-
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/RtpTrackMuteHandler.h b/erizo/src/erizo/rtp/RtpTrackMuteHandler.h
deleted file mode 100644
index b457bbf..0000000
--- a/erizo/src/erizo/rtp/RtpTrackMuteHandler.h
+++ /dev/null
@@ -1,59 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_RTPTRACKMUTEHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_RTPTRACKMUTEHANDLER_H_
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-
-#include <mutex>  // NOLINT
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class TrackMuteInfo {
- public:
-  explicit TrackMuteInfo(std::string label_)
-    : label{label_}, last_original_seq_num{-1}, seq_num_offset{0},
-      last_sent_seq_num{0}, mute_is_active{false} {}
-  std::string label;
-  int32_t last_original_seq_num;
-  uint16_t seq_num_offset;
-  uint16_t last_sent_seq_num;
-  bool mute_is_active;
-};
-
-class RtpTrackMuteHandler: public Handler {
-  DECLARE_LOGGER();
-
- public:
-  RtpTrackMuteHandler();
-  void muteAudio(bool active);
-  void muteVideo(bool active);
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "track-mute";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  void muteTrack(TrackMuteInfo *info, bool active);
-  void handleFeedback(const TrackMuteInfo &info, const std::shared_ptr<DataPacket> &packet);
-  void handlePacket(Context *ctx, TrackMuteInfo *info, std::shared_ptr<DataPacket> packet);
-  inline void setPacketSeqNumber(std::shared_ptr<DataPacket> packet, uint16_t seq_number);
-
- private:
-  TrackMuteInfo audio_info_;
-  TrackMuteInfo video_info_;
-
-  WebRtcConnection* connection_;
-};
-
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_RTPTRACKMUTEHANDLER_H_
diff --git a/erizo/src/erizo/rtp/SRPacketHandler.cpp b/erizo/src/erizo/rtp/SRPacketHandler.cpp
deleted file mode 100644
index c285322..0000000
--- a/erizo/src/erizo/rtp/SRPacketHandler.cpp
+++ /dev/null
@@ -1,84 +0,0 @@
-#include "rtp/SRPacketHandler.h"
-#include "./WebRtcConnection.h"
-#include "lib/ClockUtils.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(SRPacketHandler, "rtp.SRPacketHandler");
-
-SRPacketHandler::SRPacketHandler() :
-    enabled_{true}, initialized_{false}, connection_(nullptr) {}
-
-
-void SRPacketHandler::enable() {
-  enabled_ = true;
-}
-
-void SRPacketHandler::disable() {
-  enabled_ = false;
-}
-
-
-void SRPacketHandler::handleRtpPacket(std::shared_ptr<DataPacket> packet) {
-  RtpHeader *head = reinterpret_cast<RtpHeader*>(packet->data);
-  uint32_t ssrc = head->getSSRC();
-  auto sr_selected_info_iter = sr_info_map_.find(ssrc);
-  std::shared_ptr<SRInfo> selected_info;
-  if (sr_selected_info_iter == sr_info_map_.end()) {
-    ELOG_DEBUG("message: Inserting new SSRC in sr_info_map, ssrc: %u", ssrc);
-    sr_info_map_[ssrc] = std::make_shared<SRInfo>();
-  }
-  selected_info = sr_info_map_[ssrc];
-  selected_info->sent_packets++;
-  selected_info->sent_octets += (packet->length - head->getHeaderLength());
-}
-
-
-
-void SRPacketHandler::handleSR(std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  uint32_t ssrc = chead->getSSRC();
-  auto sr_selected_info_iter = sr_info_map_.find(ssrc);
-  if (sr_selected_info_iter == sr_info_map_.end()) {
-    ELOG_DEBUG("message: handleSR no info for this SSRC, ssrc: %u", ssrc);
-    return;
-  }
-  std::shared_ptr<SRInfo> selected_info = sr_selected_info_iter->second;
-  ELOG_DEBUG("message: Rewriting SR, ssrc: %u, octets_sent_before: %u, packets_sent_before: %u"
-    " octets_sent_after %u packets_sent_after: %u", ssrc, chead->getOctetsSent(), chead->getPacketsSent(),
-    selected_info->sent_octets, selected_info->sent_packets);
-  chead->setOctetsSent(selected_info->sent_octets);
-  chead->setPacketsSent(selected_info->sent_packets);
-}
-
-void SRPacketHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  if (initialized_ && enabled_) {
-    RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-    if (!chead->isRtcp() && enabled_) {
-      handleRtpPacket(packet);
-    } else if (chead->packettype == RTCP_Sender_PT && enabled_) {
-      handleSR(packet);
-    }
-  }
-  ctx->fireWrite(std::move(packet));
-}
-
-void SRPacketHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  ctx->fireRead(std::move(packet));
-}
-
-void SRPacketHandler::notifyUpdate() {
-  if (initialized_) {
-    return;
-  }
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-  }
-  if (!connection_) {
-    return;
-  }
-  initialized_ = true;
-}
-
-}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/SRPacketHandler.h b/erizo/src/erizo/rtp/SRPacketHandler.h
deleted file mode 100644
index a94c1e7..0000000
--- a/erizo/src/erizo/rtp/SRPacketHandler.h
+++ /dev/null
@@ -1,51 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_SRPACKETHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_SRPACKETHANDLER_H_
-
-#include <memory>
-#include <string>
-
-#include "./logger.h"
-#include "pipeline/Handler.h"
-
-#define MAX_DELAY 450000
-
-namespace erizo {
-
-class WebRtcConnection;
-
-class SRPacketHandler: public Handler {
-  DECLARE_LOGGER();
-
-
- public:
-  SRPacketHandler();
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-     return "sr_handler";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
- private:
-  struct SRInfo {
-    SRInfo() : ssrc{0}, sent_octets{0}, sent_packets{0} {}
-    uint32_t ssrc;
-    uint32_t sent_octets;
-    uint32_t sent_packets;
-  };
-
-  bool enabled_, initialized_;
-  WebRtcConnection* connection_;
-  std::map<uint32_t, std::shared_ptr<SRInfo>> sr_info_map_;
-
-  void handleRtpPacket(std::shared_ptr<DataPacket> packet);
-  void handleSR(std::shared_ptr<DataPacket> packet);
-};
-}  // namespace erizo
-
-#endif  // ERIZO_SRC_ERIZO_RTP_SRPACKETHANDLER_H_
diff --git a/erizo/src/erizo/rtp/SenderBandwidthEstimantionHandler.cpp b/erizo/src/erizo/rtp/SenderBandwidthEstimantionHandler.cpp
deleted file mode 100644
index 56ec587..0000000
--- a/erizo/src/erizo/rtp/SenderBandwidthEstimantionHandler.cpp
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
-#include "./MediaDefinitions.h"
-#include "rtp/SenderBandwidthEstimationHandler.h"
-
-namespace erizo {
-
-DEFINE_LOGGER(SenderBandwidthEstimationHandler, "rtp.SenderBandwidthEstimationHandler");
-
-constexpr duration SenderBandwidthEstimationHandler::kMinUpdateEstimateInterval;
-
-SenderBandwidthEstimationHandler::SenderBandwidthEstimationHandler(std::shared_ptr<Clock> the_clock) :
-  connection_{nullptr}, bwe_listener_{nullptr}, clock_{the_clock}, initialized_{false}, enabled_{true},
-  received_remb_{false}, period_packets_sent_{0}, estimated_bitrate_{0}, estimated_loss_{0},
-  estimated_rtt_{0}, last_estimate_update_{clock::now()}, sender_bwe_{new SendSideBandwidthEstimation()} {
-    sender_bwe_->SetSendBitrate(kStartSendBitrate);
-  };
-
-SenderBandwidthEstimationHandler::SenderBandwidthEstimationHandler(const SenderBandwidthEstimationHandler&& handler) :  // NOLINT
-    connection_{handler.connection_},
-    bwe_listener_{handler.bwe_listener_},
-    clock_{handler.clock_},
-    initialized_{handler.initialized_},
-    enabled_{handler.enabled_},
-    received_remb_{false},
-    period_packets_sent_{handler.period_packets_sent_},
-    estimated_bitrate_{handler.estimated_bitrate_},
-    estimated_loss_{handler.estimated_loss_},
-    estimated_rtt_{handler.estimated_rtt_},
-    sender_bwe_{handler.sender_bwe_},
-    sr_delay_data_{std::move(handler.sr_delay_data_)} {}
-
-
-void SenderBandwidthEstimationHandler::enable() {
-  enabled_ = true;
-}
-
-void SenderBandwidthEstimationHandler::disable() {
-  enabled_ = false;
-}
-
-void SenderBandwidthEstimationHandler::notifyUpdate() {
-  if (initialized_) {
-    return;
-  }
-  auto pipeline = getContext()->getPipelineShared();
-  if (pipeline && !connection_) {
-    connection_ = pipeline->getService<WebRtcConnection>().get();
-    processor_ = pipeline->getService<RtcpProcessor>();
-  }
-  if (!connection_) {
-    return;
-  }
-  stats_ = pipeline->getService<Stats>();
-  if (!stats_) {
-    return;
-  }
-  initialized_ = true;
-}
-
-void SenderBandwidthEstimationHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (chead->isFeedback()) {
-    char* packet_pointer = packet->data;
-    int rtcp_length = 0;
-    int total_length = 0;
-    int current_block = 0;
-
-    do {
-      packet_pointer+=rtcp_length;
-      chead = reinterpret_cast<RtcpHeader*>(packet_pointer);
-      rtcp_length = (ntohs(chead->length) + 1) * 4;
-      total_length += rtcp_length;
-      ELOG_DEBUG("%s ssrc %u, sourceSSRC %u, PacketType %u", connection_->toLog(),
-          chead->getSSRC(),
-          chead->getSourceSSRC(),
-          chead->getPacketType());
-      switch (chead->packettype) {
-        case RTCP_Receiver_PT:
-          {
-            if (chead->getSourceSSRC() != connection_->getVideoSinkSSRC()) {
-              continue;
-            }
-            ELOG_DEBUG("%s, Analyzing Video RR: PacketLost %u, Ratio %u, current_block %d, blocks %d"
-                ", sourceSSRC %u, ssrc %u",
-                connection_->toLog(),
-                chead->getLostPackets(),
-                chead->getFractionLost(),
-                current_block,
-                chead->getBlockCount(),
-                chead->getSourceSSRC(),
-                chead->getSSRC());
-            // calculate RTT + Update receiver block
-            uint32_t delay_since_last_ms = (chead->getDelaySinceLastSr() * 1000) / 65536;
-            int64_t now_ms = ClockUtils::timePointToMs(clock_->now());
-            uint32_t last_sr = chead->getLastSr();
-
-            auto value = std::find_if(sr_delay_data_.begin(), sr_delay_data_.end(),
-                [last_sr](const std::shared_ptr<SrDelayData> sr_info) {
-                return sr_info->sr_ntp == last_sr;
-                });
-            // TODO(pedro) Implement alternative when there are no REMBs
-            if (received_remb_ && value != sr_delay_data_.end()) {
-                uint32_t delay = now_ms - (*value)->sr_send_time - delay_since_last_ms;
-                ELOG_DEBUG("%s message: Updating Estimate with RR, fraction_lost: %u, "
-                    "delay: %u, period_packets_sent_: %u",
-                    connection_->toLog(), chead->getFractionLost(), delay, period_packets_sent_);
-                sender_bwe_->UpdateReceiverBlock(chead->getFractionLost(),
-                    delay, period_packets_sent_, now_ms);
-                period_packets_sent_ = 0;
-                updateEstimate();
-            }
-          }
-          break;
-        case RTCP_PS_Feedback_PT:
-          {
-            if (chead->getBlockCount() == RTCP_AFB) {
-              char *uniqueId = reinterpret_cast<char*>(&chead->report.rembPacket.uniqueid);
-              if (!strncmp(uniqueId, "REMB", 4)) {
-                received_remb_ = true;
-                int64_t now_ms = ClockUtils::timePointToMs(clock_->now());
-                uint64_t bitrate = chead->getBrMantis() << chead->getBrExp();
-                uint64_t cappedBitrate = bitrate < processor_->getMaxVideoBW() ? bitrate : processor_->getMaxVideoBW();
-                chead->setREMBBitRate(cappedBitrate);
-
-                ELOG_DEBUG("%s message: Updating Estimate with REMB, bitrate %lu", connection_->toLog(),
-                    cappedBitrate);
-                sender_bwe_->UpdateReceiverEstimate(now_ms, cappedBitrate);
-                updateEstimate();
-              } else {
-                ELOG_DEBUG("%s message: Unsupported AFB Packet not REMB", connection_->toLog());
-              }
-            }
-          }
-          break;
-        default:
-          break;
-      }
-      current_block++;
-    } while (total_length < packet->length);
-  }
-  ctx->fireRead(std::move(packet));
-}
-
-void SenderBandwidthEstimationHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
-  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
-  if (!chead->isRtcp() && packet->type == VIDEO_PACKET) {
-    period_packets_sent_++;
-    time_point now = clock_->now();
-    if (received_remb_ && now - last_estimate_update_ > kMinUpdateEstimateInterval) {
-      sender_bwe_->UpdateEstimate(ClockUtils::timePointToMs(now));
-      updateEstimate();
-      last_estimate_update_ = now;
-    }
-  } else if (chead->getPacketType() == RTCP_Sender_PT &&
-      chead->getSSRC() == connection_->getVideoSinkSSRC()) {
-    analyzeSr(chead);
-  }
-  ctx->fireWrite(std::move(packet));
-}
-
-void SenderBandwidthEstimationHandler::analyzeSr(RtcpHeader* chead) {
-  uint64_t now = ClockUtils::timePointToMs(clock_->now());
-  uint32_t ntp;
-  ntp = chead->get32MiddleNtp();
-  ELOG_DEBUG("%s message: adding incoming SR to list, ntp: %u", connection_->toLog(), ntp);
-  sr_delay_data_.push_back(std::shared_ptr<SrDelayData>( new SrDelayData(ntp, now)));
-  if (sr_delay_data_.size() >= kMaxSrListSize) {
-    sr_delay_data_.pop_front();
-  }
-}
-
-void SenderBandwidthEstimationHandler::updateEstimate() {
-  sender_bwe_->CurrentEstimate(&estimated_bitrate_, &estimated_loss_,
-      &estimated_rtt_);
-  stats_->getNode()["total"].insertStat("senderBitrateEstimation",
-      CumulativeStat{static_cast<uint64_t>(estimated_bitrate_)});
-  ELOG_DEBUG("%s message: estimated bitrate %d, loss %u, rtt %ld",
-      connection_->toLog(), estimated_bitrate_, estimated_loss_, estimated_rtt_);
-  if (bwe_listener_) {
-    bwe_listener_->onBandwidthEstimate(estimated_bitrate_, estimated_loss_, estimated_rtt_);
-  }
-}
-}  // namespace erizo
-*/
diff --git a/erizo/src/erizo/rtp/SenderBandwidthEstimationHandler.h b/erizo/src/erizo/rtp/SenderBandwidthEstimationHandler.h
deleted file mode 100644
index 9bbc23a..0000000
--- a/erizo/src/erizo/rtp/SenderBandwidthEstimationHandler.h
+++ /dev/null
@@ -1,73 +0,0 @@
-#ifndef ERIZO_SRC_ERIZO_RTP_SENDERBANDWIDTHESTIMATIONHANDLER_H_
-#define ERIZO_SRC_ERIZO_RTP_SENDERBANDWIDTHESTIMATIONHANDLER_H_
-#include "pipeline/Handler.h"
-#include "./logger.h"
-#include "./WebRtcConnection.h"
-#include "./rtp/RtcpProcessor.h"
-#include "lib/Clock.h"
-
-#include "webrtc/modules/bitrate_controller/send_side_bandwidth_estimation.h"
-
-namespace erizo {
-using webrtc::SendSideBandwidthEstimation;
-
-
-class SenderBandwidthEstimationListener {
- public:
-  virtual ~SenderBandwidthEstimationListener() {}
-  virtual void onBandwidthEstimate(int estimated_bitrate, uint8_t estimated_loss,
-      int64_t estimated_rtt) = 0;
-};
-
-class SenderBandwidthEstimationHandler : public Handler,
-  public std::enable_shared_from_this<SenderBandwidthEstimationHandler> {
-  DECLARE_LOGGER();
-
- public:
-  static const uint16_t kMaxSrListSize = 20;
-  static const uint32_t kStartSendBitrate = 300000;
-  static constexpr duration kMinUpdateEstimateInterval = std::chrono::milliseconds(25);
-
- public:
-  explicit SenderBandwidthEstimationHandler(std::shared_ptr<Clock> the_clock = std::make_shared<SteadyClock>());
-  explicit SenderBandwidthEstimationHandler(const SenderBandwidthEstimationHandler&& handler);  // NOLINT
-  virtual ~SenderBandwidthEstimationHandler() {}
-
-  void enable() override;
-  void disable() override;
-
-  std::string getName() override {
-    return "sender_bwe";
-  }
-
-  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
-  void notifyUpdate() override;
-
-  void analyzeSr(RtcpHeader *head);
-
-  void setListener(SenderBandwidthEstimationListener* listener) {
-    bwe_listener_ = listener;
-  }
-
- private:
-  WebRtcConnection* connection_;
-  std::shared_ptr<RtcpProcessor> processor_;
-  SenderBandwidthEstimationListener* bwe_listener_;
-  std::shared_ptr<Clock> clock_;
-  bool initialized_;
-  bool enabled_;
-  bool received_remb_;
-  uint32_t period_packets_sent_;
-  int estimated_bitrate_;
-  uint8_t estimated_loss_;
-  int64_t estimated_rtt_;
-  time_point last_estimate_update_;
-  std::shared_ptr<SendSideBandwidthEstimation> sender_bwe_;
-  std::list<std::shared_ptr<SrDelayData>> sr_delay_data_;
-  std::shared_ptr<Stats> stats_;
-
-  void updateEstimate();
-};
-}  // namespace erizo
-#endif  //  ERIZO_SRC_ERIZO_RTP_SENDERBANDWIDTHESTIMATIONHANDLER_H_
diff --git a/erizo/src/erizo/rtp/StatsHandler.cpp b/erizo/src/erizo/rtp/StatsHandler.cpp
index e3284cd..353f54d 100644
--- a/erizo/src/erizo/rtp/StatsHandler.cpp
+++ b/erizo/src/erizo/rtp/StatsHandler.cpp
@@ -188,7 +188,8 @@ void IncomingStatsHandler::notifyUpdate() {
 
 void IncomingStatsHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
   processPacket(packet);
-  ctx->fireRead(std::move(packet));
+  if (ctx)
+    ctx->fireRead(std::move(packet));
 }
 
 OutgoingStatsHandler::OutgoingStatsHandler() : connection_{nullptr} {}
@@ -208,7 +209,8 @@ void OutgoingStatsHandler::notifyUpdate() {
 
 void OutgoingStatsHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
   processPacket(packet);
-  ctx->fireWrite(std::move(packet));
+  if (ctx)
+    ctx->fireWrite(std::move(packet));
 }
 
 }  // namespace erizo
-- 
2.7.4

