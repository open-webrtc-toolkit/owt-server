From 5501c5b05e3f8869f2725c645fda76390dd99bdb Mon Sep 17 00:00:00 2001
From: Chen Li1 <li1.chen@intel.com>
Date: Wed, 26 Dec 2018 12:25:48 +0800
Subject: [PATCH] Add FeedbackGenerator for audio packets

---
 erizo/src/erizo/WebRtcConnection.cpp               |   4 +-
 .../erizo/rtp/RtcpFeedbackGenerationHandler.cpp    | 117 +++++++++++++++++++++
 .../src/erizo/rtp/RtcpFeedbackGenerationHandler.h  |  57 ++++++++++
 3 files changed, 176 insertions(+), 2 deletions(-)
 create mode 100644 erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.cpp
 create mode 100644 erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.h

diff --git a/erizo/src/erizo/WebRtcConnection.cpp b/erizo/src/erizo/WebRtcConnection.cpp
index 8cd38e3..d7c3760 100644
--- a/erizo/src/erizo/WebRtcConnection.cpp
+++ b/erizo/src/erizo/WebRtcConnection.cpp
@@ -22,7 +22,7 @@
 // #include "rtp/FecReceiverHandler.h"
 #include "rtp/RtcpProcessorHandler.h"
 // #include "rtp/RtpRetransmissionHandler.h"
-// #include "rtp/RtcpFeedbackGenerationHandler.h"
+#include "rtp/RtcpFeedbackGenerationHandler.h"
 // #include "rtp/RtpPaddingRemovalHandler.h"
 // #include "rtp/StatsHandler.h"
 // #include "rtp/SRPacketHandler.h"
@@ -337,7 +337,7 @@ void WebRtcConnection::initializePipeline() {
   // pipeline_->addFront(PliPacerHandler());
   // pipeline_->addFront(BandwidthEstimationHandler());
   // pipeline_->addFront(RtpPaddingRemovalHandler());
-  // pipeline_->addFront(RtcpFeedbackGenerationHandler());
+  pipeline_->addFront(RtcpFeedbackGenerationHandler());
   // pipeline_->addFront(RtpRetransmissionHandler());
   // pipeline_->addFront(SRPacketHandler());
   // pipeline_->addFront(SenderBandwidthEstimationHandler());
diff --git a/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.cpp b/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.cpp
new file mode 100644
index 0000000..4b29b2f
--- /dev/null
+++ b/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.cpp
@@ -0,0 +1,117 @@
+#include "rtp/RtcpFeedbackGenerationHandler.h"
+#include "./WebRtcConnection.h"
+
+namespace erizo {
+
+DEFINE_LOGGER(RtcpFeedbackGenerationHandler, "rtp.RtcpFeedbackGenerationHandler");
+
+RtcpFeedbackGenerationHandler::RtcpFeedbackGenerationHandler(bool nacks_enabled,
+    std::shared_ptr<Clock> the_clock)
+  : connection_{nullptr}, enabled_{true}, initialized_{false}, nacks_enabled_{nacks_enabled}, clock_{the_clock} {}
+
+void RtcpFeedbackGenerationHandler::enable() {
+  enabled_ = true;
+}
+
+void RtcpFeedbackGenerationHandler::disable() {
+  enabled_ = false;
+}
+
+void RtcpFeedbackGenerationHandler::read(Context *ctx, std::shared_ptr<DataPacket> packet) {
+  // Pass packets to RR and NACK Generator
+  RtcpHeader *chead = reinterpret_cast<RtcpHeader*>(packet->data);
+
+  if (!initialized_) {
+    ctx->fireRead(std::move(packet));
+    return;
+  }
+
+  if (chead->getPacketType() == RTCP_Sender_PT) {
+    uint32_t ssrc = chead->getSSRC();
+    auto generator_it = generators_map_.find(ssrc);
+    if (generator_it != generators_map_.end()) {
+      generator_it->second->rr_generator->handleSr(packet);
+    } else {
+      ELOG_DEBUG("message: no RrGenerator found, ssrc: %u", ssrc);
+    }
+    ctx->fireRead(std::move(packet));
+    return;
+  }
+  bool should_send_rr = false;
+  bool should_send_nack = false;
+
+  if (!chead->isRtcp()) {
+    RtpHeader *head = reinterpret_cast<RtpHeader*>(packet->data);
+    uint32_t ssrc = head->getSSRC();
+    auto generator_it = generators_map_.find(ssrc);
+    if (generator_it != generators_map_.end()) {
+        should_send_rr = generator_it->second->rr_generator->handleRtpPacket(packet);
+        if (nacks_enabled_) {
+          should_send_nack = generator_it->second->nack_generator->handleRtpPacket(packet);
+        }
+    } else {
+      ELOG_DEBUG("message: no Generator found, ssrc: %u", ssrc);
+    }
+
+    if (should_send_rr || should_send_nack) {
+      ELOG_DEBUG("message: Should send Rtcp, ssrc %u", ssrc);
+      std::shared_ptr<DataPacket> rtcp_packet = generator_it->second->rr_generator->generateReceiverReport();
+      if (nacks_enabled_ && generator_it->second->nack_generator != nullptr) {
+        generator_it->second->nack_generator->addNackPacketToRr(rtcp_packet);
+      }
+      ctx->fireWrite(std::move(rtcp_packet));
+    }
+  }
+  ctx->fireRead(std::move(packet));
+}
+
+void RtcpFeedbackGenerationHandler::write(Context *ctx, std::shared_ptr<DataPacket> packet) {
+  ctx->fireWrite(std::move(packet));
+}
+
+void RtcpFeedbackGenerationHandler::notifyUpdate() {
+  if (initialized_) {
+    return;
+  }
+
+  if (!getContext()) {
+    return;
+  }
+
+  auto pipeline = getContext()->getPipelineShared();
+  if (!pipeline) {
+    return;
+  }
+
+  connection_ = pipeline->getService<WebRtcConnection>().get();
+  if (!connection_) {
+    return;
+  }
+  // TODO(pedro) detect if nacks are enabled here with the negotiated SDP scanning the rtp_mappings
+  // std::vector<uint32_t> video_ssrc_list = connection_->getVideoSourceSSRCList();
+  // std::for_each(video_ssrc_list.begin(), video_ssrc_list.end(), [this] (uint32_t video_ssrc) {
+  //   if (video_ssrc != 0) {
+  //     auto video_generator = std::make_shared<RtcpGeneratorPair>();
+  //     generators_map_[video_ssrc] = video_generator;
+  //     auto video_rr = std::make_shared<RtcpRrGenerator>(video_ssrc, VIDEO_PACKET, clock_);
+  //     video_generator->rr_generator = video_rr;
+  //     ELOG_DEBUG("%s, message: Initialized video rrGenerator, ssrc: %u", connection_->toLog(), video_ssrc);
+  //     if (nacks_enabled_) {
+  //       ELOG_DEBUG("%s, message: Initialized video nack generator, ssrc %u", connection_->toLog(), video_ssrc);
+  //       auto video_nack = std::make_shared<RtcpNackGenerator>(video_ssrc, clock_);
+  //       video_generator->nack_generator = video_nack;
+  //     }
+  //   }
+  // });
+  uint32_t audio_ssrc = connection_->getAudioSourceSSRC();
+  if (audio_ssrc != 0) {
+    auto audio_generator = std::make_shared<RtcpGeneratorPair>();
+    generators_map_[audio_ssrc] = audio_generator;
+    auto audio_rr = std::make_shared<RtcpRrGenerator>(audio_ssrc, AUDIO_PACKET, clock_);
+    audio_generator->rr_generator = audio_rr;
+    ELOG_DEBUG("%s, message: Initialized audio, ssrc: %u", connection_->toLog(), audio_ssrc);
+  }
+  initialized_ = true;
+}
+
+}  // namespace erizo
diff --git a/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.h b/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.h
new file mode 100644
index 0000000..9676d78
--- /dev/null
+++ b/erizo/src/erizo/rtp/RtcpFeedbackGenerationHandler.h
@@ -0,0 +1,57 @@
+#ifndef ERIZO_SRC_ERIZO_RTP_RTCPFEEDBACKGENERATIONHANDLER_H_
+#define ERIZO_SRC_ERIZO_RTP_RTCPFEEDBACKGENERATIONHANDLER_H_
+
+#include <memory>
+#include <string>
+#include <map>
+
+#include "./logger.h"
+#include "pipeline/Handler.h"
+#include "rtp/RtcpRrGenerator.h"
+#include "rtp/RtcpNackGenerator.h"
+#include "lib/ClockUtils.h"
+
+#define MAX_DELAY 450000
+
+namespace erizo {
+
+class WebRtcConnection;
+
+class RtcpGeneratorPair {
+ public:
+  std::shared_ptr<RtcpRrGenerator> rr_generator;
+  std::shared_ptr<RtcpNackGenerator> nack_generator;
+};
+
+
+class RtcpFeedbackGenerationHandler: public Handler {
+  DECLARE_LOGGER();
+
+
+ public:
+  explicit RtcpFeedbackGenerationHandler(bool nacks_enabled = true,
+      std::shared_ptr<Clock> the_clock = std::make_shared<SteadyClock>());
+
+
+  void enable() override;
+  void disable() override;
+
+  std::string getName() override {
+     return "rtcp_feedback_generation";
+  }
+
+  void read(Context *ctx, std::shared_ptr<DataPacket> packet) override;
+  void write(Context *ctx, std::shared_ptr<DataPacket> packet) override;
+  void notifyUpdate() override;
+
+ private:
+  WebRtcConnection *connection_;
+  std::map<uint32_t, std::shared_ptr<RtcpGeneratorPair>> generators_map_;
+
+  bool enabled_, initialized_;
+  bool nacks_enabled_;
+  std::shared_ptr<Clock> clock_;
+};
+}  // namespace erizo
+
+#endif  // ERIZO_SRC_ERIZO_RTP_RTCPFEEDBACKGENERATIONHANDLER_H_
-- 
2.7.4

